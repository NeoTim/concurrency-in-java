{"./":{"url":"./","title":"前言","keywords":"","body":"Java 并发编程学习笔记 记录 Java 并发编程的相关知识。部分内容会分析一下源码，这里使用的 JDK 版本为 1.8.0_111。 "},"并发基础.html":{"url":"并发基础.html","title":"并发编程基础","keywords":"","body":"并发编程基础 线程 ThreadLocal "},"线程.html":{"url":"线程.html","title":"线程","keywords":"","body":"线程 目录 HelloWorld 线程状态 获得线程状态 线程优先级 守护线程 睡眠 中断 处理中断 使用场景 Wait and Notify 生产者消费者模式 Thread 方法 init start join yield currentThread 参考文章 HelloWorld 在 Java 中有两种方式创建线程，第一种方式是实现 Runnable 接口，第二种方式是继承 Thread 类，下面是使用示例： public class RunnableDemo implements Runnable{ @Override public void run() { System.out.println(\"I am in runnable Demo\"); } public static void main(String[] args) { Thread thread = new Thread(new RunnableDemo()); thread.start(); } } public class ThreadDemo extends Thread{ @Override public void run() { System.out.println(\"I am in Thread Demo\"); } public static void main(String[] args) { Thread thread = new ThreadDemo(); thread.start(); } } 如果启动线程，需要调用 start 方法，直接运行 run 不会启动新的线程。 线程状态 在线程执行期间，会经历多种状态，下面是一个示意图： 图片来自 Java 并发编程的艺术 下面是线程生命周期对应的几种状态 New - 初始状态，线程刚被创建，但是还没有调用 start 方法 Runnable(Ready to run) - 可运行状态，其他线程调用了该线程的 start 方法。该状态的位于可运行的线程池中，等待被线程调度选中，获得 CPU 的使用权。 Running - 运行状态，Runnable 线程获得了 CPU 使用权，执行程序代码。 Blocked - 阻塞状态，表示线程被锁阻塞。例如进入 synchronized 同步块时等待锁。 Waiting - 等待状态，处于该状态的线程一个是调用了下面3个方法：Object.wait, Thread.join 或者 LockSupport.park。处于 Waiting 状态的线程需要等待其他线程做出一些特定行为，例如通过调用 Object.wait() 等待的线程需要另外一个线程执行 Object.notify() 或者 Object.notifyAll() 来唤醒。 Time Waiting - 超时等待，当等待时间超过指定时间后会自行返回。 Terminated - 终止状态，表示线程已经执行完毕 在 JDK 中定义了线程的六种状态，位于 Thread.State 中，下面是 State 的定义： public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * * {@link Object#wait() Object.wait} with no timeout * {@link #join() Thread.join} with no timeout * {@link LockSupport#park() LockSupport.park} * * * A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called Object.wait() * on an object is waiting for another thread to call * Object.notify() or Object.notifyAll() on * that object. A thread that has called Thread.join() * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * * {@link #sleep Thread.sleep} * {@link Object#wait(long) Object.wait} with timeout * {@link #join(long) Thread.join} with timeout * {@link LockSupport#parkNanos LockSupport.parkNanos} * {@link LockSupport#parkUntil LockSupport.parkUntil} * */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 获得线程状态 Thread 类提供了 getState 方法来获得线程状态，下面是一个使用示例： public class StateDemo extends Thread { @Override public void run() { System.out.printf(\"%-18s %s\\n\",\"in run method:\", getState()); } public static void main(String[] args) throws InterruptedException { Thread thread = new StateDemo(); System.out.printf(\"%-18s %s\\n\",\"init:\", thread.getState()); thread.run(); System.out.printf(\"%-18s %s\\n\", \"after run:\", thread.getState()); thread.start(); System.out.printf(\"%-18s %s\\n\",\"after start:\", thread.getState()); Thread.sleep(1); System.out.printf(\"%-18s %s\\n\",\"finish:\", thread.getState()); } } 线程优先级 在 Java 标准中，可以通过设置优先级来调整线程获得时间片的优先程度。Java 中定义的线程优先级的范围是1~10，默认优先级是 5，下面是 Thread 类中关于几个变量的定义： /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 通过 setPriority 方法可以设置线程的优先级。原则上优先级高的线程会优先获得执行时间，但是并不能保证一定会这样，而且在不同的 JVM 以及操作系统中，对线程优先级的划分和优先级的支持程度是不一样，有些操作系统有可能会忽略优先级的设定。下面是一个使用线程优先级的示例： public class PriorityDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 输出结果为： Thread-0(1), loop 0 Thread-0(1), loop 1 Thread-0(1), loop 2 Thread-0(1), loop 3 Thread-0(1), loop 4 Thread-0(1), loop 5 Thread-0(1), loop 6 Thread-0(1), loop 7 Thread-0(1), loop 8 Thread-0(1), loop 9 Thread-1(10), loop 0 Thread-1(10), loop 1 Thread-1(10), loop 2 Thread-1(10), loop 3 Thread-1(10), loop 4 Thread-1(10), loop 5 Thread-1(10), loop 6 Thread-1(10), loop 7 Thread-1(10), loop 8 Thread-1(10), loop 9 从结果可以看到，优先级并没有起到什么作用。所以程序的正确性不能依赖线程的优先级高低。 守护线程 守护 （Daemon） 线程是一种支持型线程，主要用作后天的调度以及支持性工作。虚拟机的垃圾回收线程就是守护线程。当 Java 虚拟机中不存在非守护线程时，Java 虚拟机就会退出。通过 setDaemon 方法设置守护线程。需要注意的一点是当 Java 虚拟机退出守护线程时，finally 块并不一定会执行。下面是一个使用示例： public class DaemonDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try{ TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"run finally in daemon thread.\"); } } }); thread.setDaemon(true); thread.start(); } } 运行上面的程序，不会输出 run finally in daemon thread.，因为主线程结束时，TimeUnit.SECONDS.sleep(1); 还没执行完。所以不要用守护线程来完成资源回收的工作。关于守护线程具体有什么应用，可以参考下面的回答：http://stackoverflow.com/questions/7067578/when-are-daemon-threads-useful 睡眠 Thread 中 sleep 方法会使线程进入睡眠状态，从而让出 CPU 时间，供其它线程使用。sleep 是一个静态方法，只会使当前线程进入睡眠状态。同时线程在睡眠时不会让出拥有的对象锁。它的主要作用就是为了不让当前线程霸占进程所获取的 CPU 资源，给其他的线程留出执行的时间。sleep方法有两个重载的形式，一种是结果一个毫秒时间 （ millisecond），一个是接受一个毫秒 + 纳秒时间（nanosecond），如下所示： public static native void sleep(long millis) throws InterruptedException; public static void sleep(long millis, int nanos) throws InterruptedException { if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } sleep(millis); } 从上面的代码中我们可以看到，对于 sleep(long millis, int nanos) 方法，线程最终还是按照毫秒睡眠的，只是超过纳秒时间超过 0.5 毫秒，将睡眠的毫秒时间加 1。看上去这个方面并没有作用，那么为什么还要定义这个方法呢，具体的可以参考这里 What's the purpose of sleep(long millis, int nanos)?，大体意思就是，有些系统支持纳秒级睡眠的操作，并且纳秒级睡眠对该系统比较重要。但是有些系统比如 Windows 并不支持纳秒级睡眠，所以为了兼容不同的系统，就定义了该方法，对于不支持纳秒睡眠的系统，用毫秒来代替。还要注意的一点就是这里传入的睡眠时间是线程的最少的睡眠时间，到达了指定的睡眠时间后，线程有可能无法获得 CPU 时间，因此就无法立即执行。如果对睡眠的线程调用 interrupt 方法，会使线程抛出 InterruptedException 异常而终止睡眠状态。下面是一个示例： public class SleepDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try { for(int i = 0; i 中断 Java 中的中断机制是一种协作机制，通过中断并不能直接终止另外一个线程，而需要被中断的线程自己处理中断。运行面的代码，程序会一直执行下去，即便在主线程里对 demo 线程执行了中断操作，demo 线程还是会继续执行。下面的代码中 demo.interrupt() 操作只是将 demo 线程的中断状态设为 true，并没有实质性的操作。 public class InterruptDemo { public static void main(String[] args) throws InterruptedException { Thread demo = new Thread(new Runnable() { @Override public void run() { int threshold = 10000; int index = 1; while (true) { if(index++ % threshold == 0) { System.out.println(index); index = 1; } } } }); demo.start(); TimeUnit.SECONDS.sleep(1); demo.interrupt(); } } 每个线程中都有一个与中断相关联的 boolean 属性，用来表示线程的中断状态（interrupt status）。中断状态初始时为 false。当另外一个线程通过调用 interrupt 方法中断一个线程时，会出现以下两种情况： 如果被中断线程正在执行一个低级可中断的阻塞方法，例如 Thread.sleep()、Thread.join() 或者 Object.wait()，那么它将取消阻塞并且抛出 InterruptedException 如果线程没有执行上面的方法，那么 interrupt 只是将该线程的中断状态设置为 true。在被中断的线程里可以通过轮询中断状态，查看它是否被请求正在停止做的事。 中断状态可以通过 isInterrupted() 方法来读取，该方法只会读取中断状态。还有一个静态方法 -- Thread.interrupted()，该方法会首先读取中断状态，然后清除当前的中断状态（中断状态重设为 false）。下面是两种方法的源码： /** * Tests whether the current thread has been interrupted. The * interrupted status of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return true if the current thread has been interrupted; * false otherwise. * @see #isInterrupted() * @revised 6.0 */ public static boolean interrupted() { return currentThread().isInterrupted(true); } /** * Tests whether this thread has been interrupted. The interrupted * status of the thread is unaffected by this method. * * A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return true if this thread has been interrupted; * false otherwise. * @see #interrupted() * @revised 6.0 */ public boolean isInterrupted() { return isInterrupted(false); } /** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */ private native boolean isInterrupted(boolean ClearInterrupted); 处理中断 在前面提到，对于低级的阻塞方法，如果线程被设置中断，会跑出 InterruptedException，当线程抛出 InterruptedException 之后，线程的中断状态会被重置为 false，下面是一个示例： public void testInterruptException() throws InterruptedException { Thread thread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(4000); } catch (InterruptedException e) { System.out.println(\"Thread is interrupted, and current stage is: \" + Thread.currentThread().isInterrupted()); } } }); thread.start(); Thread.sleep(1000); thread.interrupt(); } 输出结果如下： Thread is interrupted, and current stage is: false 对于会抛出 InterruptedException 的阻塞方法，可以使用下面几种策略处理： 将异常抛给上层调用方法 public void method() throws InterruptedException {} 在将异常抛出之前做一些清理工作 public void method() throws InterruptedException{ try{ value = 10; } catch(InterruptedException e) { value = 0; throw e; } } 在本层方法处理使用该方式需要注意的不要 生吞中断。在上面我们提到抛出 InterruptedException 异常之后，线程中断状态会被设置为 false，如果不做处理，那么这样上层的调用方法就无法准确的获得当前线程的中断状态（不管当前线程是否被中断，上层方法获得的线程状态总是 false，就类似于中断被下层方法“吞”了）。所以，我们在捕捉了异常之后，应该重新调用 interrupt() 设置中断状态： public static void handleInterruptException() { Thread thread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(4000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); //e.printStackTrace(); } } }); thread.start(); thread.interrupt(); } 对于一般的方法，我们可以使用轮询的方式来查看当前线程的中断状态，根据中断状态做出相应的处理： public static void handleInterruptByHand() throws InterruptedException { Thread thread = new Thread(new Runnable() { @Override public void run() { int max = 10000000, index = 0; while (!Thread.currentThread().isInterrupted()) { index++; if (index > max) { index = 0; System.out.println(\"doing task......\"); } } System.out.println(\"finish task\"); } }); thread.start(); Thread.sleep(100); thread.interrupt(); } 使用场景 中断的使用场景大概有以下几个： 点击某个桌面应用中的取消按钮时； 某个操作超过了一定的执行时间限制需要中止时； 多个线程做相同的事情，只要一个线程成功其它线程都可以取消时； 一组线程中的一个或多个出现错误导致整组都无法继续时； 当一个应用或服务需要停止时。 Wait and Notify 在 Java 中可以用 wait/notify 来实现进程间的通信，一个经典的例子就是生产者和消费者模型。与 wait/notify 相关的函数有下面5个，这 5 个函数都是 Object 类中的方法，所以线程 wait 或者 notify 时都会关联一个相关的对象。 public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException { if (timeout 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos > 0) { timeout++; } wait(timeout); } public final void wait() throws InterruptedException { wait(0); } public final native void notify(); public final native void notifyAll(); 首先来说一下上述函数的功能： wait() - 使线程处于针对于当前对象的等待状态。通过另外一个线程调用等待对象的 notify() 或者 notifyAll() 方法可以唤醒等待的线程。wait 方法会抛出 InterruptedException，也就是说如果对等待线程调用 interrupt() 方法，也会使线程退出等待状态。在线程调用某个对象的 wait 方法之前，需要首先获得该对象的锁。当线程处于等待时会释放掉该对象的锁。当等待线程被唤醒之后需要重新获得等待对象的锁。处于等待状态的线程不会再占用 CPU 资源。 wait(long) / wait(long, int) - 超时等待，当超过预设的的时间之后即使没有 notify 或者 interrupt，线程也会退出等待状态。 notify() - 唤醒一个针对当前对象等待的线程，如果有多个线程正在等待当前对象，会随机选择一个唤醒。 notigyAll() - 唤醒所有针对当前对象等待的线程。 为什么线程在调用对象的 wait 或者 notify 方法之前需要首先获得对象锁呢？个人觉得主要原因就是为了确保某一个时间内只有一个线程执行该对象的 wait 或者 notify 方法。假设线程 1 正在执行 a.wait() ，随后线程 2 执行 a.notify()（线程 1 还没完成等待工作），线程 1 和 2 都没有获得对象锁，那么问题来了，因为线程 1 还没有完成等待的操作，那么线程 2 也就不知道线程 1 在等待，也就不会唤醒线程 1，当线程 1 完成等待操作之后，线程 2 也早已完成唤醒操作，线程 1 就会一直处于等待状态。 在 Java 中每个对象都有一个内置的锁，被称为 intrinsic lock 或者 monitor lock，Java 的 API 文档中经常把这个内置锁简称为 monitor。这里将其称为对象锁。获得对象锁的途径有下面三种（直接从 Javadoc 中抄的）： By executing a synchronized instance method of that object. By executing the body of a {@code synchronized} statement that synchronizes on the object. For objects of type {@code Class,} by executing a synchronized static method of that class. 也就是下面三种方式： // 该方法获得是当前对象的锁 public synchronized void method(){} // 该方法获得的是 Class 对象的锁 public synchronized static void staticMethod(){} // 该方法获得是 obj 对象的锁 synchronized (obj) { obj.notify(); } 所以我们看到在使用 wait 或者 notify 方法时，必定要和 synchronized 方法或者 synchronized 同步块相关联，诸如下面的形式： synchronized(obj) { obj.wait(); } public synchronized void method() throws InterruptedException { wait(); } 为了保证程序的正确性，我们也需要对象的修改做同步。如果同步对象修改和 wait/notify 之间有一定的关联，那么需要将这两个操作放到一个同步块中。例如生产者消费者模型中：生产者生产了商品需要唤醒消费者，就需要将生产商品和唤醒消费者的操作放到一个同步块中，如下面的形式。 // buffer 是共享变量 Queue buffer = new LinkedList (); public void method() { synchronized(buffer) { buffer.add(data); notify(); } } 假设对两者分别同步，如下面的代码： class BlockingQueue { Queue buffer = new LinkedList(); public void give(String data) { synchronized (buffer) { buffer.add(data); } synchronized (buffer) { notify(); } } public String take() throws InterruptedException { synchronized (buffer) { while (buffer.isEmpty()) wait(); } synchronized (buffer) { return buffer.remove(); } } } 对于上述代码，下面是有可能发生的情况： 一个消费者线程调用 take() 方法，发现 buffer 为空 在消费者线程调用 wait() 方法之前，生产者线程来了，它调用 give() 方法，生产东西放到了 buffer 里并调用 notify() 方法 此时消费者开始调用 wait() 方法，假设此后生产者线程都不再生产商品，即不在调用 give() 方法了，那么消费者线程将一直等待下去，即便有商品可用。 所以需要将共享变量的修改以及 wait/notify 调用放到同一个同步块中。 同时对于 wait 的条件判断，我们需要使用 while，而不是 if ，如下所示： synchronized(obj) { while (condition) { wait(); } } 这是因为线程可能存在 spurious wakeup，也就是说即便没有 notify , interrupt 或者超时，线程也有可能从 wait 的状态中醒过来。所以需要用 while 循环来判断是否需要线程再次进入 wait 状态。 关于 wait 和 notify 方法为什么会定义在 Object 类里，可以参考 这篇文章。 生产者消费者模式 http://www.infoq.com/cn/articles/producers-and-consumers-mode https://software.intel.com/zh-cn/blogs/2014/02/28/java http://blog.csdn.net/luohuacanyue/article/details/14648185 http://stackoverflow.com/questions/2779484/why-must-wait-always-be-in-synchronized-block http://www.jianshu.com/p/75d154292dcc 下面是生产者消费者的一个简单示例 import java.util.LinkedList; import java.util.Queue; public class ProducerConsumer { public static class Storage { private final int MAX_ITEM = 5; private Queue queue = new LinkedList<>(); public synchronized void put(Integer item) { while (queue.size() >= MAX_ITEM) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } queue.add(item); System.out.println(\"produce product: \" + item); notifyAll(); } public synchronized Integer take() { Integer item = 0; while (queue.isEmpty()) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // slow down the consumer speed. try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } item = queue.poll(); System.out.println(\"consume product: \" + item); notifyAll(); return item; } } public static class ProducerThread implements Runnable { private Storage storage; public ProducerThread(Storage storage) { this.storage = storage; } @Override public void run() { int num = 20; for (int i = 0; i Thread 方法 在 Thread 类中定义了一些其他的方法，下面介绍一下这些方法。 init 在运行线程之前首先构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，例如线程所属的线程组、线程优先级等信息。Thread 类通过一个私有的 init 方法，用来初始化线程，下面是代码： /** * Initializes a Thread. * * @param g the Thread group * @param target the object whose run() method gets called * @param name the name of the new Thread * @param stackSize the desired stack size for the new thread, or * zero to indicate that this parameter is to be ignored. * @param acc the AccessControlContext to inherit, or * AccessController.getContext() if null */ private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name.toCharArray(); // 当前正在运行的线程是新线程的父线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 在上面的过程中，一个新构造的线程对象是由其 Parent 线程来进行空间分配的，而 Child 线程继承了父线程是否为 Daemon、优先级和加载资源的 contextClassLoader以及可继承的 ThreadLocal，同时还会分配一个唯一的线程 ID （nextThreadID 方法，是一个 synchronized 方法）来标识这个Child 线程 start 通过调用 start 方法来启动一个线程，需要注意的是直接运行 run 方法是不会启动新的线程的。下面是 start 的代码，我们看到 start 方法其实是调用了一个 native 方法来启动线程的。 public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); join 如果线程 T 执行了 thread.join() 语句，那么线程 T 将等待 thread 线程执行完，再往下执行，下面是一个使用示例： public class JoinDemo { public static class JoinThread implements Runnable{ @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"in JoinThread\"); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new JoinThread()); thread.start(); System.out.println(\"in main thread: before thread.join()\"); thread.join(); System.out.println(\"in main thread: after thread.join()\"); } } 下面是 join 方法的实现： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } join(millis); } public final void join() throws InterruptedException { join(0); } public final native boolean isAlive(); 我们看到 join 实际上是调用了 wait 方法，wait 获得的对象锁就是 thread 对象，当 thread 执行完之后再唤醒 wait 方法（底层实现的）。 yield yield 是 Thread 类中的一个静态方法。yield 方法会给调度器发送一个暗示 （hint），告诉调度器当前线程将要让出 CPU 资源，让其他同优先级或者高优先级的线程来使用 CPU。使用这个方法有几点需要注意的地方： 调度器可以选择忽略 yield 发出的暗示。 不同的系统以及不同的 Java 版本对于 yield 的实现方法不同，具体的可以参考 这篇文章。在 Windows 的高版本 JDK 中（>=1.6），yield 只是将当前线程从运行状态 （running）变为就绪状态（ready），当前线程还是有可能再次竞争到 CPU 资源，再次执行。在 Linux 的实现中，需要其他线程都获得了 CPU 资源执行（不一定执行完）之后，被 yield 的线程才可以再次获取 CPU 资源。 Java 中的线程优先级也是个不靠谱的东西。 和线程优先级一样，程序的正确性不要依赖于 yield 方法。一般来说，yield 只用于调试。下面是一个示例： public class YieldDemo { public static class YieldThread implements Runnable { @Override public void run() { int num = 10; for (int i = 0; i currentThread 通过 currentThread 方法可以获得当前正在运行的线程，下面是获得主线程信息的一个例子： public class CurrentThreadDemo { public static void main(String[] args) { Thread thread = Thread.currentThread(); System.out.println(thread.getId() + \" \" + thread.getName()); } } 参考文章 Java 并发编程的艺术 Java 理论与实践: 处理 InterruptedException 详细分析Java中断机制 Concurrent Programming in Java 如何在 Java 中正确使用 wait, notify 和 notifyAll The Java™ Tutorials -- Concurrency Java - Multithreading Multithreading in java with examples "},"ThreadLocal.html":{"url":"ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 线程局部变量 使用示例 具体实现 ThreadLocalMap 散列表 实现 副本变量存取 ThreadLocal 散列值 应用场景 参考文章 线程局部变量 在多线程环境下，之所以会有并发问题，就是因为不同的线程会同时访问同一个共享变量，例如下面的形式 public class MultiThreadDemo { public static class Number { private int value = 0; public void increase() throws InterruptedException { value = 10; Thread.sleep(10); System.out.println(\"increase value: \" + value); } public void decrease() throws InterruptedException { value = -10; Thread.sleep(10); System.out.println(\"decrease value: \" + value); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread decreaseThread = new Thread(new Runnable() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }); increaseThread.start(); decreaseThread.start(); } } 在上面的代码中，increase 线程和 decrease 线程会操作同一个 number 中 value，那么输出的结果是不可预测的，因为当前线程修改变量之后但是还没输出的时候，变量有可能被另外一个线程修改，下面是一种可能的情况： increase value: 10 decrease value: 10 一种解决方法是在 increase() 和 decrease() 方法上加上 synchronized 关键字进行同步，这种做法其实是将 value 的 赋值 和 打印 包装成了一个原子操作，也就是说两者要么同时进行，要不都不进行，中间不会有额外的操作。我们换个角度考虑问题，如果 value 只属于 increase 线程或者 decrease 线程，而不是被两个线程共享，那么也不会出现竞争问题。一种比较常见的形式就是局部（local）变量（这里排除局部变量引用指向共享对象的情况），如下所示： public void increase() throws InterruptedException { int value = 10; Thread.sleep(10); System.out.println(\"increase value: \" + value); } 不论 value 值如何改变，都不会影响到其他线程，因为在每次调用 increase 方法时，都会创建一个 value 变量，该变量只对当前调用 increase 方法的线程可见。借助于这种思想，我们可以对每个线程创建一个共享变量的副本，该副本只对当前线程可见（可以认为是线程私有的变量），那么修改该副本变量时就不会影响到其他的线程。一个简单的思路是使用 Map 存储每个变量的副本，将当前线程的 id 作为 key，副本变量作为 value 值，下面是一个实现： public class SimpleImpl { public static class CustomThreadLocal { private Map cacheMap = new HashMap<>(); private int defaultValue ; public CustomThreadLocal(int value) { defaultValue = value; } public Integer get() { long id = Thread.currentThread().getId(); if (cacheMap.containsKey(id)) { return cacheMap.get(id); } return defaultValue; } public void set(int value) { long id = Thread.currentThread().getId(); cacheMap.put(id, value); } } public static class Number { private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException { value.set(10); Thread.sleep(10); System.out.println(\"increase value: \" + value.get()); } public void decrease() throws InterruptedException { value.set(-10); Thread.sleep(10); System.out.println(\"decrease value: \" + value.get()); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread decreaseThread = new Thread(new Runnable() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }); increaseThread.start(); decreaseThread.start(); } } 但是上面的实现会存在下面的问题： 每个线程对应的副本变量的生命周期不是由线程决定的，而是由共享变量的生命周期决定的。在上面的例子中，即便线程执行完，只要 number 变量存在，线程的副本变量依然会存在（存放在 number 的 cacheMap 中）。但是作为特定线程的副本变量，该变量的生命周期应该由线程决定，线程消亡之后，该变量也应该被回收。 多个线程有可能会同时操作 cacheMap，需要对 cacheMap 进行同步处理。 为了解决上面的问题，我们换种思路，每个线程创建一个 Map，存放当前线程中副本变量，用 CustomThreadLocal 的实例作为 key 值，下面是一个示例： public class SimpleImpl2 { public static class CommonThread extends Thread { Map cacheMap = new HashMap<>(); } public static class CustomThreadLocal { private int defaultValue; public CustomThreadLocal(int value) { defaultValue = value; } public Integer get() { Integer id = this.hashCode(); Map cacheMap = getMap(); if (cacheMap.containsKey(id)) { return cacheMap.get(id); } return defaultValue; } public void set(int value) { Integer id = this.hashCode(); Map cacheMap = getMap(); cacheMap.put(id, value); } public Map getMap() { CommonThread thread = (CommonThread) Thread.currentThread(); return thread.cacheMap; } } public static class Number { private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException { value.set(10); Thread.sleep(10); System.out.println(\"increase value: \" + value.get()); } public void decrease() throws InterruptedException { value.set(-10); Thread.sleep(10); System.out.println(\"decrease value: \" + value.get()); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new CommonThread() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }; Thread decreaseThread = new CommonThread() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }; increaseThread.start(); decreaseThread.start(); } } 在上面的实现中，当线程消亡之后，线程中 cacheMap 也会被回收，它当中存放的副本变量也会被全部回收，并且 cacheMap 是线程私有的，不会出现多个线程同时访问一个 cacheMap 的情况。在 Java 中，ThreadLocal 类的实现就是采用的这种思想，注意只是思想，实际的实现和上面的并不一样。 使用示例 Java 使用 ThreadLocal 类来实现线程局部变量模式，ThreadLocal 使用 set 和 get 方法设置和获取变量，下面是函数原型： public void set(T value); public T get(); 下面是使用 ThreadLocal 的一个完整示例： public class ThreadLocalDemo { private static ThreadLocal threadLocal = new ThreadLocal<>(); private static int value = 0; public static class ThreadLocalThread implements Runnable { @Override public void run() { threadLocal.set((int)(Math.random() * 100)); value = (int) (Math.random() * 100); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.printf(Thread.currentThread().getName() + \": threadLocal=%d, value=%d\\n\", threadLocal.get(), value); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new ThreadLocalThread()); Thread thread2 = new Thread(new ThreadLocalThread()); thread.start(); thread2.start(); thread.join(); thread2.join(); } } 下面是一种可能的输出： Thread-0: threadLocal=87, value=15 Thread-1: threadLocal=69, value=15 我们看到虽然 threadLocal 是静态变量，但是每个线程都有自己的值，不会受到其他线程的影响。 具体实现 ThreadLocal 的实现思想，我们在前面已经说了，每个线程维护一个 ThreadLocalMap 的映射表，映射表的 key 是 ThreadLocal 实例本身，value 是要存储的副本变量。ThreadLocal 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。 如下图所示： 图片来自 http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/ 我们从下面三个方面看下 ThreadLocal 的实现： 存储线程副本变量的数据结构 如何存取线程副本变量 如何对 ThreadLocal 的实例进行 Hash ThreadLocalMap 线程使用 ThreadLocalMap 来存储每个线程副本变量，它是 ThreadLocal 里的一个静态内部类。ThreadLocalMap 也是采用的散列表（Hash）思想来实现的，但是实现方式和 HashMap 不太一样。我们首先看下散列表的相关知识： 散列表 理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图： 图片来自 数据结构与算法分析: C语法描述 在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式： 分离链表法（separate chaining） 开放定址法（open addressing） 分离链表法分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。下面是一个示意图： 图片来自 http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm 开放定址法开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 -- 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示： 图片来自 http://alexyyek.github.io/2014/12/14/hashCollapse/ 关于两种方式的比较，可以参考 这篇文章。ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。 实现 我们知道 Map 是一种 key-value 形式的数据结构，所以在散列数组中存储的元素也是 key-value 的形式。ThreadLocalMap 使用 Entry 类来存储数据，下面是该类的定义： static class Entry extends WeakReference > { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) { super(k); value = v; } } Entry 将 ThreadLocal 实例作为 key，副本变量作为 value 存储起来。注意 Entry 中对于 ThreadLocal 实例的引用是一个弱引用，该引用定义在 Reference 类（WeakReference的父类）中，下面是 super(k) 最终调用的代码： Reference(T referent) { this(referent, null); } Reference(T referent, ReferenceQueue queue) { this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue; } 关于弱引用和为什么使用弱引用可以参考 Java 理论与实践: 用弱引用堵住内存泄漏 和 深入分析 ThreadLocal 内存泄漏问题。下面看一下 ThreadLocalMap 的 set 函数 private void set(ThreadLocal key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置 int i = key.threadLocalHashCode & (len - 1); // 使用线性探测法查找元素 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); // ThreadLocal 对应的 key 存在，直接覆盖之前的值 if (k == key) { e.value = value; return; } // key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前数组中的 Entry 是一个陈旧（stale）的元素 if (k == null) { // 用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏，具体可以看源代码，没看太懂 replaceStaleEntry(key, value, i); return; } } // ThreadLocal 对应的 key 不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的 Entry。 tab[i] = new Entry(key, value); int sz = ++size; // cleanSomeSlot 清理陈旧的 Entry（key == null），具体的参考源码。如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash。 if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } 关于 set 方法，有几点需要地方： int i = key.threadLocalHashCode & (len - 1);，这里实际上是对 len-1 进行了取余操作。之所以能这样取余是因为 len 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。 在 replaceStaleEntry 和 cleanSomeSlots 方法中都会清理一些陈旧的 Entry，防止内存泄漏 threshold 的值大小为 threshold = len * 2 / 3; rehash 方法中首先会清理陈旧的 Entry，如果清理完之后元素数量仍然大于 threshold 的 3/4，则进行扩容操作（数组大小变为原来的 2倍）private void rehash() { expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } 我们再看一下 getEntry （没有 get 方法，就叫 getEntry）方法： private Entry getEntry(ThreadLocal key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } 因为 ThreadLocalMap 中采用开放定址法，所以当前 key 的散列值和元素在数组中的索引并不一定完全对应。所以在 get 的时候，首先会看 key 的散列值对应的数组元素是否为要查找的元素，如果不是，再调用 getEntryAfterMiss 方法查找后面的元素。 private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } 最后看一下删除操作。删除其实就是将 Entry 的键值设为 null，变为陈旧的 Entry。然后调用 expungeStaleEntry 清理陈旧的 Entry。 private void remove(ThreadLocal key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len - 1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } 副本变量存取 前面说完了 ThreadLocalMap，副本变量的存取操作就很好理解了。下面是 ThreadLocal 中的 set 和 get 方法的实现： public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T) e.value; return result; } } return setInitialValue(); } 存取的基本流程就是首先获得当前线程的 ThreadLocalMap，将 ThreadLocal 实例作为键值传入 Map，然后就是进行相关的变量存取工作了。线程中的 ThreadLocalMap 是懒加载的，只有真正的要存变量时才会调用 createMap 创建，下面是 createMap 的实现： void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } 如果想要给 ThreadLocal 的副本变量设置初始值，需要重写 initialValue 方法，如下面的形式： ThreadLocal threadLocal = new ThreadLocal() { protected Integer initialValue() { return 0; } }; ThreadLocal 散列值 当创建了一个 ThreadLocal 的实例后，它的散列值就已经确定了，下面是 ThreadLocal 中的实现： /** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */ private final int threadLocalHashCode = nextHashCode(); /** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); /** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; /** * Returns the next hash code. */ private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } 我们看到 threadLocalHashCode 是一个常量，它通过 nextHashCode() 函数产生。nextHashCode() 函数其实就是在一个 AtomicInteger 变量（初始值为0）的基础上每次累加 0x61c88647，使用 AtomicInteger 为了保证每次的加法是原子操作。而 0x61c88647 这个就比较神奇了，它可以使 hashcode 均匀的分布在大小为 2 的 N 次方的数组里。下面写个程序测试一下: public static void main(String[] args) { AtomicInteger hashCode = new AtomicInteger(); int hash_increment = 0x61c88647; int size = 16; List list = new ArrayList <> (); for (int i = 0; i 我们将 size 设为 16，32 和 64 分别测试一下： // size=16 original:[0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] // size=32 original:[0, 7, 14, 21, 28, 3, 10, 17, 24, 31, 6, 13, 20, 27, 2, 9, 16, 23, 30, 5, 12, 19, 26, 1, 8, 15, 22, 29, 4, 11, 18, 25] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31] // size=64 original:[0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 6, 13, 20, 27, 34, 41, 48, 55, 62, 5, 12, 19, 26, 33, 40, 47, 54, 61, 4, 11, 18, 25, 32, 39, 46, 53, 60, 3, 10, 17, 24, 31, 38, 45, 52, 59, 2, 9, 16, 23, 30, 37, 44, 51, 58, 1, 8, 15, 22, 29, 36, 43, 50, 57] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63] 可以看到随着 size 的变化，hashcode 总能均匀的分布。其实这就是 Fibonacci Hashing，具体可以参考 这篇文章。所以虽然 ThreadLocal 的 hashcode 是固定的，当 ThreadLocalMap 中的散列表调整大小（变为原来的 2 倍）之后重新散列，hashcode 仍能均匀的分布在散列表中。 应用场景 摘自 Java并发编程：深入剖析ThreadLocal 最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如 private static ThreadLocal connectionHolder = new ThreadLocal () { public Connection initialValue() { return DriverManager.getConnection(DB_URL); } }; public static Connection getConnection() { return connectionHolder.get(); } private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } 参考文章 http://www.iteye.com/topic/103804 http://www.jianshu.com/p/529c03d9b67e http://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java http://jerrypeng.me/2013/06/thread-local-and-magical-0x61c88647/ ThreadLocal是否会引发内存泄露的分析（转） [Java并发包学习七]解密ThreadLocal 数据结构与算法分析: C语法描述 "},"显式锁.html":{"url":"显式锁.html","title":"显式锁","keywords":"","body":"显式锁 使用 synchronized 关键字将会隐式的获取锁，但是它将锁的获取和释放固化了，这种方式简化了同步的管理，但是可扩展性和灵活性较差。通过使用 Java 提供的显式锁，我们可以更加灵活地使用锁处理同步，并且可以方便地自定义锁。下面是与 synchronized 相比，显式锁特有的功能： 可以尝试非阻塞的获取锁 在获取锁时可以响应中断 在获取锁时可以响应超时 公平锁 非公平锁 自旋锁 可重入锁 偏向锁 轻量级锁 重量级锁 读写锁 互斥锁 锁消除 锁粗化 悲观锁 乐观锁 共享锁 排他锁 "},"Lock框架.html":{"url":"Lock框架.html","title":"Lock 框架","keywords":"","body":"Lock 框架 示例 Lock 框架体系 参考资料 示例 通过使用显式锁，我们可以更加灵活的来处理线程同步。同时使用显式锁可以实现 synchronized 所没有的功能，下面是使用显式锁的一个示例： import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Created by Jikai Zhang on 2017/4/4. */ public class ReentrantLockTest { private static int count = 1; private static Lock lock = new ReentrantLock(); static class CustomThread implements Runnable { @Override public void run() { lock.lock(); try { count++; Thread.sleep(1000); System.out.println(Thread.currentThread().toString() + \": \" + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } public static void main(String[] args) { Thread thread = new Thread(new CustomThread()); Thread thread2 = new Thread(new CustomThread()); thread.start(); thread2.start(); } } Lock 框架体系 图片来自 https://my.oschina.net/xianggao/blog/88477 参考资料 Java 并发：Lock 框架详解 Java Threads Java Concurrency / Multithreading Tutorial "},"AbstractQueuedSynchronizer.html":{"url":"AbstractQueuedSynchronizer.html","title":"AbstractQueuedSynchronizer","keywords":"","body":"队列同步器 前言 AQS 和 synchronized 基本使用 CAS 操作 同步队列 Node 类 独占锁的获取和释放 共享锁获取和释放 中断 超时 参考文章 前言 队列同步器 AbstractQueuedSynchronizer（以下简称 AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个 int 成员变量来表示同步状态，通过 CAS 操作对同步状态进行修改，确保状态的改变是安全的。通过内置的 FIFO （First In First Out）队列来完成资源获取线程的排队工作。 AQS 和 synchronized 在介绍 AQS 的使用之前，需要首先说明一点，AQS 同步和 synchronized 关键字同步（以下简称 synchronized 同步）是采用的两种不同的机制。首先看下 synchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。 在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进入同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有修改成功了之后，线程才可以进入同步块。注意上面提到的两个条件： state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和这种方式类似，没有找到相关的资料） 成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。 当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所以在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解。 基本使用 本节摘自 Java 并发编程的艺术 AQS 的设计是基于模板方法的，使用者需要继承 AQS 并重写指定的方法。在后续的流程中，AQS 提供的模板方法会调用重写的方法。一般来说，我们需要重写的方法主要有下面 5 个： 方法名称 描述 protected boolean tryAcquire(int) 独占式获取锁，实现该方法需要查询当前状态并判断同步状态是否和预期值相同，然后使用 CAS 操作设置同步状态 protected boolean tryRelease(int) 独占式释放锁，实际也是修改同步变量 protected int tryAcquireShared(int) 共享式获取锁，返回大于等于 0 的值，表示获取锁成功，反之获取失败 protected boolean tryReleaseShared(int) 共享式释放锁 protected boolean isHeldExclusively() 判断调用该方法的线程是否持有互斥锁 在自定义的同步组件中，我们一般会调用 AQS 提供的模板方法。AQS 提供的模板方法基本上分为 3 类： 独占式获取与释放锁、共享式获取与释放锁以及查询同步队列中的等待线程情况。下面是相关的模板方法： 方法名称 描述 void acquire(int) 独占式获取锁，如果当前线程成功获取锁，那么方法就返回，否则会将当前线程放入同步队列等待。该方法会调用重写的 tryAcquire(int arg) 方法判断是否可以获得锁 void acquireInterruptibly(int) 和 acquire(int) 相同，但是该方法响应中断，当线程在同步队列中等待时，如果线程被中断，会抛出 InterruptedException 异常并返回。 boolean tryAcquireNanos(int, long) 在 acquireInterruptibly(int) 基础上添加了超时控制，同时支持中断和超时，当在指定时间内没有获得锁时，会返回 false，获取到了返回 true void acquireShared(int) 共享式获得锁，如果成功获得锁就返回，否则将当前线程放入同步队列等待，与独占式获取锁的不同是，同一时刻可以有多个线程获得共享锁，该方法调用 tryAcquireShared(int) acquireSharedInterruptibly(int) 与 acquireShared(int) 相同，该方法响应中断 tryAcquireSharedNanos(int, long) 在 acquireSharedInterruptibly(int) 基础上添加了超时控制 boolean release(int) 独占式释放锁，该方法会在释放锁后，将同步队列中第一个等待节点唤醒 boolean releaseShared(int) 共享式释放锁 Collection getQueuedThreads() 获得同步队列中等待的线程集合 自定义组件通过使用同步器提供的模板方法来实现自己的同步语义。下面我们通过两个示例，看下如何借助于 AQS 来实现锁的同步语义。我们首先实现一个独占锁（排它锁），独占锁就是说在某个时刻内，只能有一个线程持有独占锁，只有持有锁的线程释放了独占锁，其他线程才可以获取独占锁。下面是具体实现： import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.AbstractQueuedSynchronizer; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; /** * Created by Jikai Zhang on 2017/4/6. * * 自定义独占锁 */ public class Mutex implements Lock { // 通过继承 AQS，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer { // 当前线程是否被独占 @Override protected boolean isHeldExclusively() { return getState() == 1; } // 尝试获得锁 @Override protected boolean tryAcquire(int arg) { // 只有当 state 的值为 0，并且线程成功将 state 值修改为 1 之后，线程才可以获得独占锁 if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } @Override protected boolean tryRelease(int arg) { // state 为 0 说明当前同步块中没有锁了，无需释放 if (getState() == 0) { throw new IllegalMonitorStateException(); } // 将独占的线程设为 null setExclusiveOwnerThread(null); // 将状态变量的值设为 0，以便其他线程可以成功修改状态变量从而获得锁 setState(0); return true; } Condition newCondition() { return new ConditionObject(); } } // 将操作代理到 Sync 上 private final Sync sync = new Sync(); @Override public void lock() { sync.acquire(1); } @Override public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } @Override public boolean tryLock() { return sync.tryAcquire(1); } @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(time)); } @Override public void unlock() { sync.release(1); } @Override public Condition newCondition() { return sync.newCondition(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public boolean isLocked() { return sync.isHeldExclusively(); } public static void withoutMutex() throws InterruptedException { System.out.println(\"Without mutex: \"); int threadCount = 2; final Thread threads[] = new Thread[threadCount]; for (int i = 0; i 程序的运行结果如下面所示。我们看到使用了 Mutex 之后，线程 0 和线程 1 不会再交替执行，而是当一个线程执行完，另外一个线程再执行。 Without mutex: Thread-0: j =0 Thread-1: j =0 Thread-0: j =20000 Thread-1: j =20000 Thread-0: j =40000 Thread-1: j =40000 Thread-0: j =60000 Thread-1: j =60000 Thread-1: j =80000 Thread-0: j =80000 With mutex: Thread-0: j =0 Thread-0: j =20000 Thread-0: j =40000 Thread-0: j =60000 Thread-0: j =80000 Thread-1: j =0 Thread-1: j =20000 Thread-1: j =40000 Thread-1: j =60000 Thread-1: j =80000 下面在看一个共享锁的示例。在该示例中，我们定义两个共享资源，即同一时间内允许两个线程同时执行。我们将同步变量的初始状态 state 设为 2，当一个线程获取了共享锁之后，将 state 减 1，线程释放了共享锁后，将 state 加 1。状态的合法范围是 0、1 和 2，其中 0 表示已经资源已经用光了，此时线程再要获得共享锁就需要进入同步序列等待。下面是具体实现： import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.AbstractQueuedSynchronizer; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; /** * Created by Jikai Zhang on 2017/4/9. * * 自定义共享锁 */ public class TwinsLock implements Lock { private static class Sync extends AbstractQueuedSynchronizer { public Sync(int resourceCount) { if (resourceCount = 0; } @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(time)); } @Override public void unlock() { sync.releaseShared(1); } @Override public Condition newCondition() { throw new UnsupportedOperationException(); } public static void main(String[] args) { final Lock lock = new TwinsLock(); int threadCounts = 10; Thread threads[] = new Thread[threadCounts]; for (int i = 0; i 运行程序，我们会发现程序每次都会同时打印两条语句，如下面的形式，证明同时有两个线程在执行。 Thread-0 Thread-1 Thread-3 Thread-2 Thread-8 Thread-4 Thread-3 Thread-6 CAS 操作 CAS（Compare and Swap），比较并交换，通过利用底层硬件平台的特性，实现原子性操作。CAS 操作涉及到3个操作数，内存值 V，旧的期望值 A，需要修改的新值 B。当且仅当预期值 A 和 内存值 V 相同时，才将内存值 V 修改为 B，否则什么都不做。CAS 操作类似于执行了下面流程 if(oldValue == memory[valueAddress]) { memory[valueAddress] = newValue; } 在上面的流程中，其实涉及到了两个操作，比较以及替换，为了确保程序正确，需要确保这两个操作的原子性（也就是说确保这两个操作同时进行，中间不会有其他线程干扰）。现在的 CPU 中，提供了相关的底层 CAS 指令，即 CPU 底层指令确保了比较和交换两个操作作为一个原子操作进行（其实在这一点上还是有排他锁的. 只是比起用synchronized, 这里的排他时间要短的多.），Java 中的 CAS 函数是借助于底层的 CAS 指令来实现的。更多关于 CPU 底层实现的原理可以参考 这篇文章。我们来看下 Java 中对于 CAS 函数的定义： /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x); /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x); 上面三个函数定义在 sun.misc.Unsafe 类中，使用该类可以进行一些底层的操作，例如直接操作原生内存，更多关于 Unsafe 类的文章可以参考 这篇。以 compareAndSwapInt 为例，我们看下如何使用 CAS 函数： import sun.misc.Unsafe; import java.lang.reflect.Field; /** * Created by Jikai Zhang on 2017/4/8. */ public class CASIntTest { private volatile int count = 0; private static final Unsafe unsafe = getUnsafe(); private static final long offset; // 获得 count 属性在 CASIntTest 中的偏移量（内存地址偏移） static { try { offset = unsafe.objectFieldOffset(CASIntTest.class.getDeclaredField(\"count\")); } catch (NoSuchFieldException e) { throw new Error(e); } } // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() { Unsafe unsafe = null; try { Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return unsafe; } public void increment() { int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); } public static void main(String[] args) { CASIntTest casIntTest = new CASIntTest(); casIntTest.increment(); System.out.println(casIntTest.count); } } 在 CASIntTest 类中，我们定义一个 count 变量，其中 increment 方法是将 count 的值加 1。下面是 increase 方法的代码： int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); 在没有线程竞争的条件下，该代码执行的结果是将 count 变量的值加 1（多个线程竞争可能会有线程执行失败），但是在 compareAndSwapInt 函数中，我们并没有传入 count 变量，那么函数是如何修改的 count 变量值？其实我们往 compareAndSwapInt 函数中传入了 count 变量在堆内存中的地址，函数直接修改了 count 变量所在内存区域。count 属性在堆内存中的地址是由 CASIntTest 实例的起始内存地址和 count 属性相对于起始内存的偏移量决定的。其中对象属性在对象中的偏移量通过 objectFieldOffset 函数获得，函数原型如下所示。该函数接受一个 Filed 类型的参数，返回该 Filed 属性在对象中的偏移量。 /** * Report the location of a given static field, in conjunction with {@link * #staticFieldBase}. * Do not expect to perform any sort of arithmetic on this offset; * it is just a cookie which is passed to the unsafe heap memory accessors. * * Any given field will always have the same offset, and no two distinct * fields of the same class will ever have the same offset. * * As of 1.4.1, offsets for fields are represented as long values, * although the Sun JVM does not use the most significant 32 bits. * It is hard to imagine a JVM technology which needs more than * a few bits to encode an offset within a non-array object, * However, for consistency with other methods in this class, * this method reports its result as a long value. */ public native long objectFieldOffset(Field f); 下面我们再看一下 compareAndSwapInt 的函数原型。我们知道 CAS 操作需要知道 3 个信息：内存中的值，期望的旧值以及要修改的新值。通过前面的分析，我们知道通过 o 和 offset 我们可以确定属性在内存中的地址，也就是知道了属性在内存中的值。expected 对应期望的旧址，而 x 就是要修改的新值。 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); compareAndSwapInt 函数首先比较一下 expected 是否和内存中的值相同，如果不同证明其他线程修改了属性值，那么就不会执行更新操作，但是程序如果就此返回了，似乎不太符合我们的期望，我们是希望程序可以执行更新操作的，如果其他线程先进行了更新，那么就在更新后的值的基础上进行修改，所以我们一般使用循环配合 CAS 函数，使程序在更新操作完成之后再返回，如下所示： long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) { before = counter; } 下面是使用 CAS 函数实现计数器的一个实例： import sun.misc.Unsafe; import java.lang.reflect.Field; /** * Created by Jikai Zhang on 2017/4/8. */ public class CASCounter { // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() { Unsafe unsafe = null; try { Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return unsafe; } private volatile long counter = 0; private static final long offset; private static final Unsafe unsafe = getUnsafe(); static { try { offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(\"counter\")); } catch (NoSuchFieldException e) { throw new Error(e); } } public void increment() { long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) { before = counter; } } public long getCounter() { return counter; } private static long intCounter = 0; public static void main(String[] args) throws InterruptedException { int threadCount = 10; Thread threads[] = new Thread[threadCount]; final CASCounter casCounter = new CASCounter(); for (int i = 0; i 在 AQS 中，对原始的 CAS 函数封装了一下，省去了获得变量地址的步骤，如下面的形式： private static final long waitStatusOffset; static { try { waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\"waitStatus\")); } catch (Exception ex) { throw new Error(ex); } } private static final boolean compareAndSetWaitStatus(Node node, int expect, int update) { return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update); } 同步队列 AQS 依赖内部的同步队列（一个 FIFO的双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把队列中第一个等待节点线程唤醒（下图中的 Node1），使其再次尝试获取同步状态。同步队列的结构如下所示： 图片来自 http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer Head 节点本身不保存等待线程的信息，它通过 next 变量指向第一个保存线程等待信息的节点（Node1）。当线程被唤醒之后，会删除 Head 节点，而唤醒线程所在的节点会设置为 Head 节点（Node1 被唤醒之后，Node1会被置为 Head 节点）。下面我们看下 JDK 中同步队列的实现。 Node 类 首先看在节点所对应的 Node 类： static final class Node { /** * 标志是独占式模式还是共享模式 */ static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; /** * 线程等待状态的有效值 */ static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; /** * 线程状态，合法值为上面 4 个值中的一个 */ volatile int waitStatus; /** * 当前节点的前置节点 */ volatile Node prev; /** * 当前节点的后置节点 */ volatile Node next; /** * 当前节点所关联的线程 */ volatile Thread thread; /** * 指向下一个在某个条件上等待的节点，或者指向 SHARE 节点，表明当前处于共享模式 */ Node nextWaiter; final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // Used to establish initial head or SHARED marker } Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } } 在 Node 类中定义了四种等待状态： CANCELED： 1，因为等待超时 （timeout）或者中断（interrupt），节点会被置为取消状态。处于取消状态的节点不会再去竞争锁，也就是说不会再被阻塞。节点会一直保持取消状态，而不会转换为其他状态。处于 CANCELED 的节点会被移出队列，被 GC 回收。 SIGNAL： -1，表明当前的后继结点正在或者将要被阻塞（通过使用 LockSupport.pack 方法），因此当前的节点被释放（release）或者被取消时（cancel）时，要唤醒它的后继结点（通过 LockSupport.unpark 方法）。 CONDITION： -2，表明当前节点在条件队列中，因为等待某个条件而被阻塞。 PROPAGATE： -3，在共享模式下，可以认为资源有多个，因此当前线程被唤醒之后，可能还有剩余的资源可以唤醒其他线程。该状态用来表明后续节点会传播唤醒的操作。需要注意的是只有头节点才可以设置为该状态（This is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened.）。 0：新创建的节点会处于这种状态 独占锁的获取和释放 我们首先看下独占锁的获取和释放过程 独占锁获取 下面是获取独占锁的流程图： 我们通过 acquire 方法来获取独占锁，下面是方法定义 public final void acquire(int arg) { // 首先尝试获取锁，如果获取失败，会先调用 addWaiter 方法创建节点并追加到队列尾部 // 然后调用 acquireQueued 阻塞或者循环尝试获取锁 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)){ // 在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回 true // 这里的 selfInterrupt 主要是为了恢复线程的中断状态 selfInterrupt(); } } acquire 会首先调用 tryAcquire 方法来获得锁，该方法需要我们来实现，这个在前面已经提过了。如果没有获取锁，会调用 addWaiter 方法创建一个和当前线程关联的节点追加到同步队列的尾部，我们调用 addWaiter 时传入的是 Node.EXCLUSIVE，表明当前是独占模式。下面是 addWaiter 的具体实现 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // tail 指向同步队列的尾节点 Node pred = tail; // Try the fast path of enq; backup to full enq on failure if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } addWaiter 方法会首先调用 if 方法，来判断能否成功将节点添加到队列尾部，如果添加失败，再调用 enq 方法（使用循环不断重试）进行添加，下面是 enq 方法的实现： private Node enq(final Node node) { for (;;) { Node t = tail; // 同步队列采用的懒初始化（lazily initialized）的方式， // 初始时 head 和 tail 都会被设置为 null，当一次被访问时 // 才会创建 head 对象，并把尾指针指向 head。 if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } addWaiter 仅仅是将节点加到了同步队列的末尾，并没有阻塞线程，线程阻塞的操作是在 acquireQueued 方法中完成的，下面是 acquireQueued 的实现： final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); // 如果当前节点的前继节点是 head，就使用自旋（循环）的方式不断请求锁 if (p == head && tryAcquire(arg)) { // 成功获得锁，将当前节点置为 head 节点，同时删除原 head 节点 setHead(node); p.next = null; // help GC failed = false; return interrupted; } // shouldParkAfterFailedAcquire 检查是否可以挂起线程， // 如果可以挂起进程，会调用 parkAndCheckInterrupt 挂起线程， // 如果 parkAndCheckInterrupt 返回 true，表明当前线程是因为中断而退出挂起状态的， // 所以要将 interrupted 设为 true，表明当前线程被中断过 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } acquireQueued 会首先检查当前节点的前继节点是否为 head，如果为 head，将使用自旋的方式不断的请求锁，如果不是 head，则调用 shouldParkAfterFailedAcquire 查看是否应该挂起当前节点关联的线程，下面是 shouldParkAfterFailedAcquire 的实现： private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 当前节点的前继节点的等待状态 int ws = pred.waitStatus; // 如果前继节点的等待状态为 SIGNAL 我们就可以将当前节点对应的线程挂起 if (ws == Node.SIGNAL) return true; if (ws > 0) { // ws 大于 0，表明当前线程的前继节点处于 CANCELED 的状态， // 所以我们需要从当前节点开始往前查找，直到找到第一个不为 // CAECELED 状态的节点 do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } shouldParkAfterFailedAcquire 会检查前继节点的等待状态，如果前继节点状态为 SIGNAL，则可以将当前节点关联的线程挂起，如果不是 SIGNAL，会做一些其他的操作，在当前循环中不会挂起线程。如果确定了可以挂起线程，就调用 parkAndCheckInterrupt 方法对线程进行阻塞： private final boolean parkAndCheckInterrupt() { // 挂起当前线程 LockSupport.park(this); // 可以通过调用 interrupt 方法使线程退出 park 状态， // 为了使线程在后面的循环中还可以响应中断，会重置线程的中断状态。 // 这里使用 interrupted 会先返回线程当前的中断状态，然后将中断状态重置为 false， // 线程的中断状态会返回给上层调用函数，在线程获得锁后， // 如果发现线程曾被中断过，会将中断状态重新设为 true return Thread.interrupted(); } 独占锁释放 下面是释放独占锁的流程： 通过 release 方法，我们可以释放互斥锁。下面是 release 方法的实现： public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; // waitStatus 为 0，证明是初始化的空队列或者后继结点已经被唤醒了 if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 在独占模式下释放锁时，是没有其他线程竞争的，所以处理会简单一些。首先尝试释放锁，如果失败就直接返回（失败不是因为多线程竞争，而是线程本身就不拥有锁）。如果成功的话，会检查 h 的状态，然后调用 unparkSuccessor 方法来唤醒后续线程。下面是 unparkSuccessor 的实现： private void unparkSuccessor(Node node) { int ws = node.waitStatus; // 将 head 节点的状态置为 0，表明当前节点的后续节点已经被唤醒了， // 不需要再次唤醒，修改 ws 状态主要作用于 release 的判断 if (ws 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus 在 unparkSuccessor 方法中，如果发现头节点的后继结点为 null 或者处于 CANCELED 状态，会从尾部往前找（在节点存在的前提下，这样一定能找到）离头节点最近的需要唤醒的节点，然后唤醒该节点。 共享锁获取和释放 独占锁的流程和原理比较容易理解，因为只有一个锁，但是共享锁的处理就相对复杂一些了。在独占锁中，只有在释放锁之后，才能唤醒等待的线程，而在共享模式中，获取锁和释放锁之后，都有可能唤醒等待的线程。如果想要理清共享锁的工作过程，必须将共享锁的获取和释放结合起来看。这里我们先看一下共享锁的释放过程，只有明白了释放过程做了哪些工作，才能更好的理解获取锁的过程。 共享锁释放 下面是释放共享锁的流程： 通过 releaseShared 方法会释放共享锁，下面是具体的实现： public final boolean releaseShared(int releases) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } releases 是要释放的共享资源数量，其中 tryReleaseShared 的方法由我们自己重写，该方法的主要功能就是修改共享资源的数量（state + releases），因为可能会有多个线程同时释放资源，所以实现的时候，一般采用循环加 CAS 操作的方式，如下面的形式： protected boolean tryReleaseShared(int releases) { // 释放共享资源，因为可能有多个线程同时执行，所以需要使用 CAS 操作来修改资源总数。 for (;;) { int lastCount = getState(); int newCount = lastCount + releases; if (compareAndSetState(lastCount, newCount)) { return true; } } } 当共享资源数量修改了之后，会调用 doReleaseShared 方法，该方法主要唤醒同步队列中的第一个等待节点（head.next），下面是具体实现： private void doReleaseShared() { /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) { Node h = head; // head = null 说明没有初始化，head = tail 说明同步队列中没有等待节点 if (h != null && h != tail) { // 查看当前节点的等待状态 int ws = h.waitStatus; // 我们在前面说过，SIGNAL说明有后续节点需要唤醒 if (ws == Node.SIGNAL) { /* * 将当前节点的值设为 0，表明已经唤醒了后继节点 * 可能会有多个线程同时执行到这一步，所以使用 CAS 保证只有一个线程能修改成功， * 从而执行 unparkSuccessor，其他的线程会执行 continue 操作 */ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) { /* * ws 等于 0，说明无需唤醒后继结点（后续节点已经被唤醒或者当前节点没有被阻塞的后继结点）， * 也就是这一次的调用其实并没有执行唤醒后继结点的操作。就类似于我只需要一张优惠券， * 但是我的两个朋友，他们分别给我了一张，因此我就剩余了一张。然后我就将这张剩余的优惠券 * 送（传播）给其他人使用，因此这里将节点置为可传播的状态（PROPAGATE） */ continue; // loop on failed CAS } } if (h == head) // loop if head changed break; } } 从上面的实现中，doReleaseShared 的主要作用是用来唤醒阻塞的节点并且一次只唤醒一个，让该节点关联的线程去重新竞争锁，它既不修改同步队列，也不修改共享资源。 当多个线程同时释放资源时，可以确保两件事： 共享资源的数量能正确的累加 至少有一个线程被唤醒，其实只要确保有一个线程被唤醒就可以了，即便唤醒了多个线程，在同一时刻，也只能有一个线程能得到竞争锁的资格，在下面我们会看到。 所以释放锁做的主要工作还是修改共享资源的数量。而有了多个共享资源后，如何确保同步队列中的多个节点可以获取锁，是由获取锁的逻辑完成的。下面看下共享锁的获取。 共享锁的获取 下面是获取共享锁的流程 通过 acquireShared 方法，我们可以申请共享锁，下面是具体的实现： public final void acquireShared(int arg) { // 如果返回结果小于 0，证明没有获取到共享资源 if (tryAcquireShared(arg) 如果没有获取到共享资源，就会执行 doAcquireShared 方法，下面是该方法的具体实现： private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r >= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 从上面的代码中可以看到，只有前置节点为 head 的节点才有可能去竞争锁，这点和独占模式的处理是一样的，所以即便唤醒了多个线程，也只有一个线程能进入竞争锁的逻辑，其余线程会再次进入 park 状态，当线程获取到共享锁之后，会执行 setHeadAndPropagate 方法，下面是具体的实现： private void setHeadAndPropagate(Node node, long propagate) { // 备份一下头节点 Node h = head; // Record old head for check below /* * 移除头节点，并将当前节点置为头节点 * 当执行完这一步之后，其实队列的头节点已经发生改变， * 其他被唤醒的线程就有机会去获取锁，从而并发的执行该方法， * 所以上面备份头节点，以便下面的代码可以正确运行 */ setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ /* * 判断是否需要唤醒后继结点，propagate > 0 说明共享资源有剩余， * h.waitStatus 0 || h == null || h.waitStatus 判断后继结点是否需要唤醒的条件是十分宽松的，也就是一定包含必要的唤醒，但是也有可能会包含不必要的唤醒。从前面我们可以知道 doReleaseShared 函数的主要作用是唤醒后继结点，它既不修改共享资源，也不修改同步队列，所以即便有不必要的唤醒也是不影响程序正确性的。如果没有共享资源，节点会再次进入等待状态。 到了这里，脉络就比较清晰了，当一个节点获取到共享锁之后，它除了将自身设为 head 节点之外，还会判断一下是否满足唤醒后继结点的条件，如果满足，就唤醒后继结点，后继结点获取到锁之后，会重复这个过程，直到判断条件不成立。就类似于考试时从第一排往最后一排传卷子，第一排先留下一份，然后将剩余的传给后一排，后一排会重复这个过程。如果传到某一排卷子没了，那么位于这排的人就要等待，直到老师又给了他新的卷子。 中断 在获取锁时还可以设置响应中断，独占锁和共享锁的处理逻辑类似，这里我们以独占锁为例。使用 acquireInterruptibly 方法，在获取独占锁时可以响应中断，下面是具体的实现： public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } private void doAcquireInterruptibly(int arg) throws InterruptedException { final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return; } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) { // 这里会抛出异常 throw new InterruptedException(); } } } finally { if (failed) cancelAcquire(node); } } 从上面的代码中我们可以看出，acquireInterruptibly 和 acquire 的逻辑类似，只是在下面的代码处有所不同：当线程因为中断而退出阻塞状态时，会直接抛出 InterruptedException 异常。 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) { // 这里会抛出异常 throw new InterruptedException(); } 我们知道，不管是抛出异常还是方法返回，程序都会执行 finally 代码，而 failed 肯定为 true，所以抛出异常之后会执行 cancelAcquire 方法，cancelAcquire 方法主要将节点从同步队列中移除。下面是具体的实现： private void cancelAcquire(Node node) { // Ignore if node doesn't exist if (node == null) return; node.thread = null; // 跳过前面的已经取消的节点 Node pred = node.prev; while (pred.waitStatus > 0) node.prev = pred = pred.prev; // 保存下 pred 的后继结点，以便 CAS 操作使用 // 因为可能存在已经取消的节点，所以 pred.next 不一等于 node Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. // 将节点状态设为 CANCELED node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail && compareAndSetTail(node, pred)) { compareAndSetNext(pred, predNext, null); } else { // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head && ((ws = pred.waitStatus) == Node.SIGNAL || (ws 从上面的代码可以看出，节点的删除分为三种情况： 删除节点为尾节点，直接将该节点的第一个有效前置节点置为尾节点 删除节点的前置节点为头节点，则对该节点执行 unparkSuccessor 操作 删除节点为中间节点，结果如下图所示。下图中（1）表示同步队列的初始状态，假设删除 node2， node1 是正常节点（非 CANCELED），（2）就是删除 node2 后同步队列的状态，此时 node1 节点的后继已经变为 node3，也就是说当 node1 变为 head 之后，会直接唤醒 node3。当另外的一个节点中断之后再次执行 cancelAcquire，在执行下面的代码时，会使同步队列的状态由（2）变为（3），此时 node2 已经没有外界指针了，可以被回收了。如果一直没有另外一个节点中断，也就是同步队列一直处于（2）状态，那么需要等 node3 被回收之后，node2 才可以被回收。Node pred = node.prev; while (pred.waitStatus > 0) node.prev = pred = pred.prev; 超时 超时是在中断的基础上加了一层时间的判断，这里我们还是以独占锁为例。 tryAcquireNanos 支持获取锁的超时处理，下面是具体实现： public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout); } 当获取锁失败之后，会执行 doAcquireNanos 方法，下面是具体实现： private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (nanosTimeout spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 当线程超时返回时，还是会执行 cancelAcquire 方法，cancelAcquire 的逻辑已经在前面说过了，这里不再赘述。 参考文章 Java 并发编程的艺术 Java Magic. Part 4: sun.misc.Unsafe Java里的CompareAndSet(CAS) ReentrantLock的lock-unlock流程详解 深入JVM锁机制2-Lock 深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上） AbstractQueuedSynchronizer源码分析 聊聊并发（十二）—AQS分析 AbstractQueuedSynchronizer (AQS) 并发编程实践二：AbstractQueuedSynchronizer "},"线程池.html":{"url":"线程池.html","title":"线程池","keywords":"","body":"线程池 "},"ThreadPoolExecutor.html":{"url":"ThreadPoolExecutor.html","title":"ThreadPoolExecutor","keywords":"","body":"ThreadPoolExecutor 前言 基本使用 概述 具体实现 Worker 状态变量 添加任务 关闭线程池 线程池监控 参考文章 前言 线程池是并发中一项常用的优化方法，通过对线程复用，减少线程的创建，降低资源消耗，提高程序响应速度。在 Java 中我们一般通过 Exectuors 提供的工厂方法来创建线程池，但是线程池的最终实现类是 ThreadPoolExecutor，下面我们详细分析一下 ThreadPoolExecutor 的实现 基本使用 我们首先看下线程池的基本使用。在下面的代码中我们创建一个固定大小的线程池，该线程池中最多包含 5 个线程，当任务数量超过线程的数量时，就将任务添加到任务队列，等线程空闲之后再从任务队列中获取任务。 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Created by Jikai Zhang on 2017/4/17. */ public class ThreadPoolDemo { static class WorkThread implements Runnable { private String command; public WorkThread(String command) { this.command = command; } @Override public void run() { System.out.println(\"Thread-\" + Thread.currentThread().getId() + \" start. Command=\" + command); processCommand(); System.out.println(\"Thread-\" + Thread.currentThread().getId() + \" end.\"); } private void processCommand() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(5); for (int i = 0; i 概述 在分析线程池的具体实现之前，我们首先看下线程池具体的工作流程，只有先熟悉了流程，才能更好的理解线程池的实现。线程池一般都会关联一个任务队列，用来缓存任务，当线程执行完一个任务之后，会从任务队列中取下一个任务。ThreadPoolExecutor 中使用阻塞队列作为任务队列，当任务队列为空时，就会阻塞请求任务的线程。下面是 ThreadPoolExecutor 整体的图示： 图片来自 Java 并发编程的艺术 下面我们着重看下 ThreadPoolExecutor 添加任务和关闭线程池的流程。下图是 ThreadPoolExecutor 添加任务的流程： 我们首先看下添加任务的具体流程： 如果线程池中的线程数量少于 corePoolSize，那么直接创建一个新的线程（不论线程池中是否有空闲线程），然后把该任务分配给新建线程，同时将线程加入到线程池中。 如果线程池的线程数量大于等于 corePoolSize，就将任务添加到任务队列 如果任务队列已经饱和（对于有边界的任务队列），那么就看下线程池中的线程数量是否少于 maximumPoolSize，如果少于，就创建新的线程，将当前任务分配给新线程，同时将线程加入到线程池中。否则就对该任务执行 reject 策略。 在 ThreadPoolExecutor 中通过两个量来控制线程池的大小：corePoolSize 和 maximumPoolSize。corePoolSize 表示正常状态下线程池中应该持有的存活线程数量，maximumPoolSize 表示线程池可以持有的最大线程数量。当线程池中的线程数量不超过 corePoolSize 时，位于线程池中的线程被看作 core 线程，默认情况下，线程池不对 core 线程进行超时控制，也就是 core 线程会一直存活在线程池中，直到线程池被关闭（这里忽略线程异常关闭的情况）。当线程池中的线程数量超过 corePoolSize 时，额外的线程被看作非 core 线程，线程池会对这部分线程进行超时控制，当线程空闲一段时间之后会销毁该线程。非 core 线程主要用来处理某段时间并发任务特别多的情况，即之前的线程配置无法及时处理那么多的任务量，需要额外的线程来帮助。而当这批任务处理完成之后，额外的线程就有些多余了（线程越多占的资源越多），因此需要及时销毁。 ThreadPoolExecutor 定义线程数量上限是 2^29 - 1 = 536870911（后面会讲到为什么是这个数），同时用户可以自定义最大线程数量，ThreadPoolExecutor 处理时会选两者之间的较小值。当线程池的线程数量等于 maximumPoolSize 时，说明线程池也已经饱和了，此时对于新来的任务就要执行 reject 策略，JDK 中定义了四种拒绝策略： AbortPolicy：直接抛出异常，默认策略 CallerRunsPolicy：使用调用者所在的线程执行任务 DiscardOldestPolicy：丢弃当前任务队列中最前面的任务，并执行 execute 方法添加新任务 DiscardPolicy：直接丢弃任务 下面再看一下线程池的关闭。线程池的关闭分为两种：平缓关闭（shutdown）和立即关闭（shutdownNow）。当调用 shutdown 方法之后，线程池不再接受新的任务，但是仍然会将任务队列中已有的任务执行完毕。而调用 shutdownNow 方法之后，线程池不仅不再接受新的任务，也不会再执行任务队列中剩余的任务，同时会通过中断的方式尝试停止正在执行任务的线程（我们知道对于中断，线程可能响应也可能不响应，所以不能保证一定停止线程）。 具体实现 下面我们从源码的角度分析一下 ThreadPoolExecutor 的实现。 Worker ThreadPoolExecutor 中每个线程都关联一个 Worker 对象，而 ThreadPool 里实际上保存的就是线程关联的 Worker 对象。 Worker 类对线程进行包装，它除了保存关联线程的信息，还保存一些其他的信息，如线程创建时分配的首任务，线程已完成的任务数量。Worker 实现了 Runnable 接口，创建线程时往 Thread 类传的参数就是该对象，所以线程创建后会执行 Worker 的 run 方法。同时 Worker 类还继承了 AbstractQueuedSynchronizer，使自身成为一个不可重入的互斥锁（以下称为 Worker 锁，注意 Worker 锁是不可重入的，也就是说该锁只能被一个线程获取一次），因此每个线程实际上也关联了一个互斥锁。当线程执行任务时，需要首先获得关联的 Worker 锁，执行完任务之后再释放该锁。Worker 锁的主要作用是为了平缓关闭线程池时，判断线程是否空闲（根据能否获得 Worker 锁），后续会详细讲解。下面是 Worker 类的实现，我们只保留了一些必要的内容： private final class Worker extends AbstractQueuedSynchronizer implements Runnable { // 当前 Worker 对象关联的线程 final Thread thread; // 线程创建后的初始任务 Runnable firstTask; // 线程完成的任务数量 volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) { // 只有 state 为 0，线程才能获取到 Worker 锁，这里将 state 设为 -1， // 表明任何线程都无法获取锁，在 shutdown 方法中，如果要中断线程，需要首先获得线程 // 关联的 Worker 锁，而 shutdownNow 中断线程之前，会首先判断 state 是否大于等于 0 // 所以这里将 state 设为 -1，可以防止当前线程被中断 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; // 创建线程时将自身传入 this.thread = getThreadFactory().newThread(this); } /** Delegates main run loop to outer runWorker */ // 线程创建之后会运行该方法 public void run() { runWorker(this); } // 只要线程启动了，就中断线程，用于 shutdownNow 方法 void interruptIfStarted() { Thread t; if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) { try { t.interrupt(); } catch (SecurityException ignore) {} } } } 我们看到在 Worker 的构造函数中将 state 设为了 -1，注释里给出的解释是：禁止中断直到执行了 runWorker 方法。其实这里包含了两个问题：1.为什么要等到执行了 runWorker 方法 2.怎样禁止中断。对于第一个问题，我们知道中断是针对运行的线程，当线程创建之后只有调用了 start 方法，线程才真正运行，而 start 方法的调用是在 runWorker 方法中的，也就是有只有执行了 runWorker 方法，线程才真正启动。对于第二个问题，这个主要是针对 shutdown 和 shutdownNow 方法的。在 shutdown 方法中，中断线程之前会首先尝试获取线程的 Worker 锁，只有获得了 Worker 锁才对线程进行中断。而获得 Worker 锁的前提是 Worker 的锁的状态变量 state 为 0，当 state 设为 -1 之后，任何线程都无法获得该锁，那么也就无法对线程执行中断操作。而在 shutdownNow 方法中，会调用 Worker 的 interruptIfStarted 方法来中断线程，而 interruptIfStarted 方法只有在 state >= 0 时才会中断线程，所以将 state 设为 -1 可以防止线程被提前中断。当执行 runWorker 方法时，会为传入 Worker 对象执行 unlock 操作（也就是将 state 加 1），使 Worker 对象的 state 变为 0，这样就使线程处于可被中断的状态了。 状态变量 在 ThreadPoolExecutor 中定义了一个 AtomicInteger 类型的变量 ctl，用来保存线程池的状态和线程数量信息。下面是该变量的定义： private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); ctl 使用低 29 位保存线程的数量（这就是线程池最大线程数量为 2^29-1 的原因），高 3 位保存线程池的状态。为了提取出这两个信息，ThreadPoolExecutor 定义了一个低 29 位全为 1 的变量 CAPACITY，通过和 CAPACITY 进行 & 运算可以获得线程的数量，通过和 ~CAPACITY 进行 & 运算可以获得线程池的状态，下面是程序中的实现： // 存储线程数量的 bit 位数，这里是 29 private static final int COUNT_BITS = Integer.SIZE - 3; // 用于提取线程池的运行状态以及线程数量，低 29 位全为 1，高 3 位为0 private static final int CAPACITY = (1 ThreadPoolExecutor 中为线程池定义了五种状态： RUNNING：正常状态，接受新的任务，并处理任务队列中的任务 SHUTDOWN：不接受新的任务，但是处理已经在任务队列中的任务 STOP： 不接受新的任务，也不处理已经在任务队列中的任务，同时会尝试停止正在执行任务的线程 TIDYING： 线程池和任务队列都为空，该状态下线程会执行 terminated() 方法 TERMINATED：terminated() 方法执行完毕 下面是 JDK 中关于这 5 个变量的定义： // 11100000000000000000000000000000 -536870912 private static final int RUNNING = -1 下面是各状态之间的转换： RUNNING -> SHUTDOWN：调用了 shutdown() 方法 （perhaps implicitly in finalize()） (RUNNING or SHUTDOWN) -> STOP：调用了shutdownNow() 方法 SHUTDOWN -> TIDYING：线程池和任务队列都为空 STOP -> TIDYING：线程池为空 TIDYING -> TERMINATED：执行完 terminated() 方法 添加任务 通过 execute 或者 submit 方法都可以向线程池中添加一个任务，submit 会返回一个 Future 对象来获取线程的返回值，下面是 submit 方法的实现： public Future submit(Runnable task) { if (task == null) throw new NullPointerException(); RunnableFuture ftask = newTaskFor(task, null); execute(ftask); return ftask; } 我们看到 submit 中只是将 Runnable 对象包装了一下，最终还是调用了 execute 方法。下面我们看下 execute 方法的实现： public void execute(Runnable command) { // command 不能为 null if (command == null) throw new NullPointerException(); int c = ctl.get(); // 线程数量少于 corePoolSize，会创建一个新的线程执行该任务 if (workerCountOf(c) 在前面我们提到了线程池添加任务的流程，这里再重述一下 如果线程池的线程数量少于 corePoolSize，则新建一个线程，执行当前任务，并将该任务加入到线程池 如果线程池中的线程数量大于等于 corePoolSize，则首先将任务添加到任务队列 如果任务队列已满，则继续创建线程，如果线程池达到了饱和值 maximumPoolSize，则调用 reject 策略处理该任务。 addWorker 方法会创建并启动线程，当线程池不处于 Running 状态并且传入的任务不为 null，addWorker 就无法成功创建线程。下面看下它的具体实现： private boolean addWorker(Runnable firstTask, boolean core) { // retry 类似于 goto，continue retry 跳转到 retry 定义， // 而 break retry 跳出 retry retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // 我们在下面详细讲解该条件 if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty())) return false; for (;;) { int wc = workerCountOf(c); // 线程数量大于系统规定的最大线程数或者大于 corePoolSize/maximumPoolSize // 表明线程池中无法添加新的线程，这里 wc >= CAPACITY 为了防止 corePoolSize // 或者 maximumPoolSize 大于CAPACITY if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize)) { return false; } // 使用 CAS 方式将线程数量增加，如果成功就跳出 retry if (compareAndIncrementWorkerCount(c)) { break retry; } c = ctl.get(); // Re-read ctl // 如果线程池运行状态发生了改变就从 retry（外层循环）处重新开始， if (runStateOf(c) != rs) continue retry; // 程序执行到这里说 CAS 没有成功，那么就再次执行 CAS } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { // 创建 work w = new Worker(firstTask); final Thread t = w.thread; // t != null 说明线程创建成功了 if (t != null) { // 程序用一个 HashSet 存储线程，而 HashSet 不是线程的安全的， // 所以将线程加入 HashSet 的过程需要加锁。 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); // 1. rs largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { // 启动线程 t.start(); workerStarted = true; } } } finally { if (!workerStarted) addWorkerFailed(w); } return workerStarted; } 这里我们着重看下返回 false 的条件： if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty())) // 等价于 if(rs >= SHUTDOWN && (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())) 我们依次看下上面的条件： rs >= SHUTDOWN && rs != SHUTDOWN：说明线程池处于 STOP，TIDYING 或者 TERMINATED 状态下，处于这三种状态说明线程池处理完了所有任务或者不再执行剩余的任务，可以直接返回 rs == SHUTDOWN && firstTask != null：如果上面的条件不成立，说明当前线程池的状态一定是处于 SHUTDOWN 状态，在 execute 方法中，我们提到了如果传入 null，说明创建线程是为了执行队列中剩余的任务（此时线程池中没有工作线程），这时就不应该返回。而如果 firstTask != null，说明不是为了处理队列中剩余的任务，可以返回。 rs == SHUTDOWN && workQueue.isEmpty()：说经任务队列中的任务已经全部执行完了，无需创建新的线程，可以返回。 当创建了线程并成功启动之后，会执行 Worker 的 run 方法，而该方法最终调用了 ThreadPoolExecutor 的 runWorker 方法，并且将自身作为参数传进去了，下面是 runWorker 方法的实现： final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; // 这里将 Worker 中的 state 设为 0，以便其他线程可以获得锁 // 从而可以中断当前线程 w.unlock(); // allow interrupts // 用来标记线程是正常退出循环还是异常退出 boolean completedAbruptly = true; try { // 如果任务不为空，说明是刚创建线程，如果任务为空，则从队列中取任务 // 如果队列没有任务，线程就会阻塞在这里 while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted()) wt.interrupt(); try { // 任务执行之前做一些处理，空函数，需要用户定义处理逻辑 beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; // 因为 runnable 方法不能抛出 checkedException ，所以这里 // 将异常包装成 Error 抛出 throw new Error(x); } finally { // 任务执行完之后做一些处理，默认空函数 afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 在上面的代码中，第一个 if 判断的逻辑有点难理解，我们将它拿出分析一下。 private static boolean runStateAtLeast(int c, int s) { return c >= s; } if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted()) wt.interrupt(); 这段 if 代码块的功能有两个： 如果当前线程池的状态小于 STOP，也就是处于 RUNNING 或者 SHUTDOWN 状态，要保证线程池中的线程处于非中断状态 如果当前线程池的状态大于等于 STOP，也就是处于 STOP，TIDYING 或者 TERMINATED 状态，要保证线程池中的线程处于中断状态 上面的 if 代码中括号比较多，我们先将其分为两个大条件： runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)) && !wt.isInterrupted() 我们先看第二个条件：!wt.isInterrupted()，该条件说明当前线程没有被中断，只有在线程没有被中断的前提下，才有可能对线程执行中断操作。然后我们将第一个大条件再进行拆分，可以分为下面两个条件： runStateAtLeast(ctl.get(), STOP) || Thread.interrupted() && runStateAtLeast(ctl.get(), STOP) 我们先看第一个条件，该条件说明线程处于 STOP 以及之后的状态，线程应该被中断。如果该条件不成立，说明当前线程不应该被中断，那么会调用 Thread.interrupted() 方法，该方法会首返回线程的中断状态，然后重置线程中断状态（设为 false），如果中断状态本来就为 false，那么就可以就可以跳出 if 代码块了，但是如果中断状态是 true，说明线程被中断过了，此时我们就要判断线程的中断是不是由 shutdownNow 方法（并发调用，该方法会中断线程池的线程，并修改线程池状态为 STOP，后面会讲到）造成的，所以我们需要再检查一下线程的状态，如果发现当前线程池已经变为 STOP 或者之后的状态，说明确实是由 shutdownNow 方法造成的，需要重新对线程进行中断，如果不是那就不需要再中断线程了。 我们看到在 runWorker 里会一直循环调用 getTask 来获取任务，下面来看下 getTask 的实现 /** * getTask 返回 null，说明当前线程需要被回收了 */ private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); int rs = runStateOf(c); // rs >= SHUTDOWN 说明当前线程池至少处于待关闭状态，不再接受新的任务 // 1. rs >= STOP： 说明不需要在再处理任务了（即便有任务） // 2. workQueue.isEmpty(): 说明任务队列中剩余的任务已经处理完了 if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } int wc = workerCountOf(c); // Are workers subject to culling? // timed 用于判断是否需要对线程进行超时控制 // 1. allowCoreThreadTimeOut: 为 true 说明可以对 core 线程进行超时控制 // 2. wc > corePoolSize: 说明线程池中有非 core 线程 boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; // 1. wc > maximumPoolSize || (timed && timedOut) // 线程数量大于 maximumPoolSize 值了 或者 允许超时控制并且超时了 // 2. wc > 1 || workQueue.isEmpty() // 线程中活动线程的数量大于 1 或者 任务队列为空（不需要在留线程执行剩余的任务了） // 如果上面 1 和 2 都成立，就使用 CAS 将线程数量减 1 并返回 null 回收当前线程 // 如果 CAS 失败了就重试 if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) { if (compareAndDecrementWorkerCount(c)) return null; continue; } try { // 如果允许超时控制，则执行 poll 方法，该方法响应超时，当 keepAliveTime 时间内 // 仍然没有获取到任务，就返回 null。take 方法不响应超时操作，当获取不到任务时会一直等待。 // 另外不管 poll 还是 take 方法都会响应中断，如果没有新的任务添加到队列中 // 会直接抛出 InterruptedException Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; // 执行到这里说明超时了 timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 当 getTask 返回 null 的时候说明线程需要被回收了，我们总结一下在 getTask 中返回 null 的情况： 线程池总工作线程数量大于 maximumPoolSize（一般是由于我们调用 setMaximumPoolSize 方法重新设置了 maximumPoolSize） 线程池已经被停止 （状态 >= STOP） 线程池处于 SHUTDOWN 状态，并且任务队列为空 线程在等待任务时超时 我们将 runWorker 和 getTask 结合起来看，整个流程就比较明朗了： 通过 while 循环不断的从任务队列中获取任务，如果当前任务队列中没有任务，就阻塞线程。如果 getTask 返回 null，表明当前线程应该被回收，执行回收线程的逻辑。 如果成功获取任务，首先判断线程池的状态，根据线程池状态设置当前线程的中断状态 在执行任务之前做一些预处理（用户实现） 执行任务 在执行任务之后做一些后处理（用户实现） 上面两个方法是整个线程池中比较核心的部分，在这两个方法中，完成了任务获取与阻塞线程的工作。下面是线程 提交 -> 处理任务 -> 回收 的流程图： 下面我们再看下 processWorkerExit 方法，该方法主要用来完成线程的回收工作： private void processWorkerExit(Worker w, boolean completedAbruptly) { // 如果 completedAbruptly 为 true，说明线程是由于抛出异常而跳出循环的， // 没有正确执行 getTask 中减少线程数量的逻辑，所以这里要将线程数量减一 if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 更新已完成的任务数量，并移除工作线程 completedTaskCount += w.completedTasks; workers.remove(w); } finally { mainLock.unlock(); } // 尝试终止线程池 tryTerminate(); int c = ctl.get(); // 如果线程状态是 SHUTDOWN 或者 RUNNING，需要保证线程中的最少线程数量 // 1. 如果线程是由于抛出异常而结束的，直接添加一个线程 // 2. 如果线程是正常结束的 // * 如果允许对 core 线程进行超时控制，并且任务队列中有任务 // 则保证线程数量大于等于 1 // * 如果不允许对 core 进行超时控制，则保证线程数量大于等于 corePoolSize if (runStateLessThan(c, STOP)) { if (!completedAbruptly) { int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 && !workQueue.isEmpty()) min = 1; if (workerCountOf(c) >= min) return; // replacement not needed } addWorker(null, false); } } 我们看到 processWorkerExit 中调用了 tryTerminate 方法，该方法主要用来终止线程池。如果线程池满足终止条件，首先将线程池状态设为 TIDYING，然后执行 terminated 方法，最后将线程池状态设为 TERMINATED。在 shutdown 和 shutdownNow 方法中也会调用该方法 。 final void tryTerminate() { for (;;) { int c = ctl.get(); // 如果出现下面三种情况，就不执行终止线程池的逻辑，直接返回 // 1. 当前线程池处于 RUNNING 状态，不能停止 // 2. 当前线程池状态为 TIDYING 或者 TERMINATED，不需要停止 // 3. 当前线程池状态为 SHUTDOWN 并且任务队列不为空 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN && !workQueue.isEmpty())) return; // 判断工作线程的数量是否为 0 if (workerCountOf(c) != 0) { // Eligible to terminate // 如果工作线程数量不为 0，就尝试中断正在线程池中的空闲线程 // ONLY_ONE 说明只尝试中断线程池中第一个线程（不管线程空不空闲） interruptIdleWorkers(ONLY_ONE); return; } final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 将线程状态设为 TIDYING，如果设置不成功说明线程池的状态发生了变化，需要重试 // 这里线程池状态从 TIDYING 到 TERMINATED 状态转换是原子的 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { try { // 执行 terminated 方法（默认空方法） terminated(); } finally { // 将线程状态设为 TERMINATED ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); } return; } } finally { mainLock.unlock(); } // else retry on failed CAS } } 在 tryTerminate 方法中， 如果满足下面两个条件，就将线程池状态设为 TERMINATED： 线程池状态为 SHUTDOWN 并且线程池和任务队列均为空 线程池状态为 STOP 并且线程池为空 如果线程池处于 SHUTDOWN 或者 STOP 状态，但是工作线程不为空，那么 tryTerminate 会尝试去中断线程池中的一个线程，这样做主要是为了防止 shutdown 的中断信号丢失（我们在 shutdown 方法处再详细讨论）。下面看下 interruptIdleWorkers 方法，该方法主要中断 空闲 线程。 private void interruptIdleWorkers(boolean onlyOne) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { for (Worker w: workers) { Thread t = w.thread; // 首先看当前线程是否已经中断，如果没有中断，就看线程是否处于空闲状态 // 如果能获得线程关联的 Worker 锁，说明线程处于空闲状态，可以中断 // 否则说明线程不能中断 if (!t.isInterrupted() && w.tryLock()) { try { t.interrupt(); } catch (SecurityException ignore) {} finally { w.unlock(); } } // 如果 onlyOne 为 true，只尝试中断第一个线程 if (onlyOne) break; } } finally { mainLock.unlock(); } } 关闭线程池 通过 shutdown 和 shutdownNow 我们可以关闭线程池，关于两者的区别在前面已经提到了，这里不再赘述。我们首先看下 shutdown 方法： public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 检查当前线程是否有关闭线程池的权限 checkShutdownAccess(); // 将线程池状态设为 SHUTDOWN advanceRunState(SHUTDOWN); // 中断线程，这里最终调用 interruptIdleWorkers(false); interruptIdleWorkers(); // hook 方法，默认为空，让用户在线程池关闭时可以做一些操作 onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } tryTerminate(); } 在前面我们知道 interruptIdleWorkers 会先检查线程是否是空闲状态，如果发现线程不是空闲状态，才会中断线程。而这时中断线程的主要目的是让在任务队列中阻塞的线程醒过来。考虑下面的情况，如果执行 interruptIdleWorkers 时，线程正在运行，所以没有被中断，但是线程执行完任务之后，任务队列恰好为空，线程就会处于阻塞状态，而此时 shutdown 已经执行完 interruptIdleWorkers 操作了（即线程错过了 shutdown 的中断信号），如果没有额外操作，线程会一直处于阻塞状态。所以为了防止这种情况，在 tryTerminate() 中也增加了 interruptIdleWorkers 操作，主要就是为了弥补 shutdown 中丢失的信号。 最后我们再看下 shutdownNow 方法： public List shutdownNow() { List tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 检查线程是否具有关闭线程池的权限 checkShutdownAccess(); // 更改线程状态 advanceRunState(STOP); // 中断线程 interruptWorkers(); // 清除任务队列，并将任务返回 tasks = drainQueue(); } finally { mainLock.unlock(); } tryTerminate(); return tasks; } 然后我们看下 interruptWorkers 方法： private void interruptWorkers() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // 不管线程是否空闲都执行中断 for (Worker w: workers) w.interruptIfStarted(); } finally { mainLock.unlock(); } } 从上面的代码中我们可以看到在 interruptWorkers 方法中，只要线程开始了，就对线程执行中断，所以 shutdownNow 的中断信号不会丢失。最后我们再看下 drainQueue 方法，该方法主要作用是清空任务队列，并将队列中剩余的任务返回。 private List drainQueue() { BlockingQueue q = workQueue; ArrayList taskList = new ArrayList (); // 该方法会将阻塞队列中的所有项添加到 taskList 中 // 然后清空任务队列，该方法是线程安全的 q.drainTo(taskList); if (!q.isEmpty()) { // 将 List 转换为 数组，传入的 Runnable[0] 用来说明是转为 Runnable 数组 for (Runnable r: q.toArray(new Runnable[0])) { if (q.remove(r)) taskList.add(r); } } return taskList; } 线程池监控 本节摘自 深入理解Java线程池：ThreadPoolExecutor 通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用 getTaskCount：线程池已经执行的和未执行的任务总数； getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount； getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize； getPoolSize：线程池当前的线程数量； getActiveCount：当前线程池中正在执行任务的线程数量。 通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。 参考文章 Java线程池架构(一)原理和源码解析 Java线程池--原理及源码分析 http://blog.csdn.net/qq_35101189/article/details/55804778 http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor 深入理解Java线程池：ThreadPoolExecutor "}}