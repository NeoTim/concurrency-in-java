{"./":{"url":"./","title":"前言","keywords":"","body":"Java 并发编程学习笔记 参考资料: Java 并发编程实战 Java 并发编程的艺术 Java并发性和多线程 The Java™ Tutorials 说明 使用的 JDK 版本为 1.8.0_111 "},"并发基础.html":{"url":"并发基础.html","title":"并发编程基础","keywords":"","body":"并发编程基础 线程 ThreadLocal "},"线程.html":{"url":"线程.html","title":"线程","keywords":"","body":"线程 目录 HelloWorld 线程状态 获得线程状态 线程优先级 守护线程 睡眠 中断 处理中断 使用场景 Wait and Notify 生产者消费者模式 Thread 方法 init start join yield currentThread 参考文章 HelloWorld 在 Java 中有两种方式创建线程，第一种方式是实现 Runnable 接口，第二种方式是继承 Thread 类，下面是使用示例： public class RunnableDemo implements Runnable{ @Override public void run() { System.out.println(\"I am in runnable Demo\"); } public static void main(String[] args) { Thread thread = new Thread(new RunnableDemo()); thread.start(); } } public class ThreadDemo extends Thread{ @Override public void run() { System.out.println(\"I am in Thread Demo\"); } public static void main(String[] args) { Thread thread = new ThreadDemo(); thread.start(); } } 如果启动线程，需要调用 start 方法，直接运行 run 不会启动新的线程。 线程状态 在线程执行期间，会经历多种状态，下面是一个示意图： 图片来自 Java 并发编程的艺术 下面是线程生命周期对应的几种状态 New - 初始状态，线程刚被创建，但是还没有调用 start 方法 Runnable(Ready to run) - 可运行状态，其他线程调用了该线程的 start 方法。该状态的位于可运行的线程池中，等待被线程调度选中，获得 CPU 的使用权。 Running - 运行状态，Runnable 线程获得了 CPU 使用权，执行程序代码。 Blocked - 阻塞状态，表示线程被锁阻塞。例如进入 synchronized 同步块时等待锁。 Waiting - 等待状态，处于该状态的线程一个是调用了下面3个方法：Object.wait, Thread.join 或者 LockSupport.park。处于 Waiting 状态的线程需要等待其他线程做出一些特定行为，例如通过调用 Object.wait() 等待的线程需要另外一个线程执行 Object.notify() 或者 Object.notifyAll() 来唤醒。 Time Waiting - 超时等待，当等待时间超过指定时间后会自行返回。 Terminated - 终止状态，表示线程已经执行完毕 在 JDK 中定义了线程的六种状态，位于 Thread.State 中，下面是 State 的定义： public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * * {@link Object#wait() Object.wait} with no timeout * {@link #join() Thread.join} with no timeout * {@link LockSupport#park() LockSupport.park} * * * A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called Object.wait() * on an object is waiting for another thread to call * Object.notify() or Object.notifyAll() on * that object. A thread that has called Thread.join() * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * * {@link #sleep Thread.sleep} * {@link Object#wait(long) Object.wait} with timeout * {@link #join(long) Thread.join} with timeout * {@link LockSupport#parkNanos LockSupport.parkNanos} * {@link LockSupport#parkUntil LockSupport.parkUntil} * */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 获得线程状态 Thread 类提供了 getState 方法来获得线程状态，下面是一个使用示例： public class StateDemo extends Thread { @Override public void run() { System.out.printf(\"%-18s %s\\n\",\"in run method:\", getState()); } public static void main(String[] args) throws InterruptedException { Thread thread = new StateDemo(); System.out.printf(\"%-18s %s\\n\",\"init:\", thread.getState()); thread.run(); System.out.printf(\"%-18s %s\\n\", \"after run:\", thread.getState()); thread.start(); System.out.printf(\"%-18s %s\\n\",\"after start:\", thread.getState()); Thread.sleep(1); System.out.printf(\"%-18s %s\\n\",\"finish:\", thread.getState()); } } 线程优先级 在 Java 标准中，可以通过设置优先级来调整线程获得时间片的优先程度。Java 中定义的线程优先级的范围是1~10，默认优先级是 5，下面是 Thread 类中关于几个变量的定义： /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 通过 setPriority 方法可以设置线程的优先级。原则上优先级高的线程会优先获得执行时间，但是并不能保证一定会这样，而且在不同的 JVM 以及操作系统中，对线程优先级的划分和优先级的支持程度是不一样，有些操作系统有可能会忽略优先级的设定。下面是一个使用线程优先级的示例： public class PriorityDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 输出结果为： Thread-0(1), loop 0 Thread-0(1), loop 1 Thread-0(1), loop 2 Thread-0(1), loop 3 Thread-0(1), loop 4 Thread-0(1), loop 5 Thread-0(1), loop 6 Thread-0(1), loop 7 Thread-0(1), loop 8 Thread-0(1), loop 9 Thread-1(10), loop 0 Thread-1(10), loop 1 Thread-1(10), loop 2 Thread-1(10), loop 3 Thread-1(10), loop 4 Thread-1(10), loop 5 Thread-1(10), loop 6 Thread-1(10), loop 7 Thread-1(10), loop 8 Thread-1(10), loop 9 从结果可以看到，优先级并没有起到什么作用。所以程序的正确性不能依赖线程的优先级高低。 守护线程 守护 （Daemon） 线程是一种支持型线程，主要用作后天的调度以及支持性工作。虚拟机的垃圾回收线程就是守护线程。当 Java 虚拟机中不存在非守护线程时，Java 虚拟机就会退出。通过 setDaemon 方法设置守护线程。需要注意的一点是当 Java 虚拟机退出守护线程时，finally 块并不一定会执行。下面是一个使用示例： public class DaemonDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try{ TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"run finally in daemon thread.\"); } } }); thread.setDaemon(true); thread.start(); } } 运行上面的程序，不会输出 run finally in daemon thread.，因为主线程结束时，TimeUnit.SECONDS.sleep(1); 还没执行完。所以不要用守护线程来完成资源回收的工作。关于守护线程具体有什么应用，可以参考下面的回答：http://stackoverflow.com/questions/7067578/when-are-daemon-threads-useful 睡眠 Thread 中 sleep 方法会使线程进入睡眠状态，从而让出 CPU 时间，供其它线程使用。sleep 是一个静态方法，只会使当前线程进入睡眠状态。同时线程在睡眠时不会让出拥有的对象锁。它的主要作用就是为了不让当前线程霸占进程所获取的 CPU 资源，给其他的线程留出执行的时间。sleep方法有两个重载的形式，一种是结果一个毫秒时间 （ millisecond），一个是接受一个毫秒 + 纳秒时间（nanosecond），如下所示： public static native void sleep(long millis) throws InterruptedException; public static void sleep(long millis, int nanos) throws InterruptedException { if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } sleep(millis); } 从上面的代码中我们可以看到，对于 sleep(long millis, int nanos) 方法，线程最终还是按照毫秒睡眠的，只是超过纳秒时间超过 0.5 毫秒，将睡眠的毫秒时间加 1。看上去这个方面并没有作用，那么为什么还要定义这个方法呢，具体的可以参考这里 What's the purpose of sleep(long millis, int nanos)?，大体意思就是，有些系统支持纳秒级睡眠的操作，并且纳秒级睡眠对该系统比较重要。但是有些系统比如 Windows 并不支持纳秒级睡眠，所以为了兼容不同的系统，就定义了该方法，对于不支持纳秒睡眠的系统，用毫秒来代替。还要注意的一点就是这里传入的睡眠时间是线程的最少的睡眠时间，到达了指定的睡眠时间后，线程有可能无法获得 CPU 时间，因此就无法立即执行。如果对睡眠的线程调用 interrupt 方法，会使线程抛出 InterruptedException 异常而终止睡眠状态。下面是一个示例： public class SleepDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try { for(int i = 0; i 中断 Java 中的中断机制是一种协作机制，通过中断并不能直接终止另外一个线程，而需要被中断的线程自己处理中断。运行面的代码，程序会一直执行下去，即便在主线程里对 demo 线程执行了中断操作，demo 线程还是会继续执行。下面的代码中 demo.interrupt() 操作只是将 demo 线程的中断状态设为 true，并没有实质性的操作。 public class InterruptDemo { public static void main(String[] args) throws InterruptedException { Thread demo = new Thread(new Runnable() { @Override public void run() { int threshold = 10000; int index = 1; while (true) { if(index++ % threshold == 0) { System.out.println(index); index = 1; } } } }); demo.start(); TimeUnit.SECONDS.sleep(1); demo.interrupt(); } } 每个线程中都有一个与中断相关联的 boolean 属性，用来表示线程的中断状态（interrupt status）。中断状态初始时为 false。当另外一个线程通过调用 interrupt 方法中断一个线程时，会出现以下两种情况： 如果被中断线程正在执行一个低级可中断的阻塞方法，例如 Thread.sleep()、Thread.join() 或者 Object.wait()，那么它将取消阻塞并且抛出 InterruptedException 如果线程没有执行上面的方法，那么 interrupt 只是将该线程的中断状态设置为 true。在被中断的线程里可以通过轮询中断状态，查看它是否被请求正在停止做的事。 中断状态可以通过 isInterrupted() 方法来读取，该方法只会读取中断状态。还有一个静态方法 -- Thread.interrupted()，该方法会首先读取中断状态，然后清除当前的中断状态（中断状态重设为 false）。下面是两种方法的源码： /** * Tests whether the current thread has been interrupted. The * interrupted status of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return true if the current thread has been interrupted; * false otherwise. * @see #isInterrupted() * @revised 6.0 */ public static boolean interrupted() { return currentThread().isInterrupted(true); } /** * Tests whether this thread has been interrupted. The interrupted * status of the thread is unaffected by this method. * * A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return true if this thread has been interrupted; * false otherwise. * @see #interrupted() * @revised 6.0 */ public boolean isInterrupted() { return isInterrupted(false); } /** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */ private native boolean isInterrupted(boolean ClearInterrupted); 处理中断 在前面提到，对于低级的阻塞方法，如果线程被设置中断，会跑出 InterruptedException，当线程抛出 InterruptedException 之后，线程的中断状态会被重置为 false，下面是一个示例： public void testInterruptException() throws InterruptedException { Thread thread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(4000); } catch (InterruptedException e) { System.out.println(\"Thread is interrupted, and current stage is: \" + Thread.currentThread().isInterrupted()); } } }); thread.start(); Thread.sleep(1000); thread.interrupt(); } 输出结果如下： Thread is interrupted, and current stage is: false 对于会抛出 InterruptedException 的阻塞方法，可以使用下面几种策略处理： 将异常抛给上层调用方法 public void method() throws InterruptedException {} 在将异常抛出之前做一些清理工作 public void method() throws InterruptedException{ try{ value = 10; } catch(InterruptedException e) { value = 0; throw e; } } 在本层方法处理使用该方式需要注意的不要 生吞中断。在上面我们提到抛出 InterruptedException 异常之后，线程中断状态会被设置为 false，如果不做处理，那么这样上层的调用方法就无法准确的获得当前线程的中断状态（不管当前线程是否被中断，上层方法获得的线程状态总是 false，就类似于中断被下层方法“吞”了）。所以，我们在捕捉了异常之后，应该重新调用 interrupt() 设置中断状态： public static void handleInterruptException() { Thread thread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(4000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); //e.printStackTrace(); } } }); thread.start(); thread.interrupt(); } 对于一般的方法，我们可以使用轮询的方式来查看当前线程的中断状态，根据中断状态做出相应的处理： public static void handleInterruptByHand() throws InterruptedException { Thread thread = new Thread(new Runnable() { @Override public void run() { int max = 10000000, index = 0; while (!Thread.currentThread().isInterrupted()) { index++; if (index > max) { index = 0; System.out.println(\"doing task......\"); } } System.out.println(\"finish task\"); } }); thread.start(); Thread.sleep(100); thread.interrupt(); } 使用场景 中断的使用场景大概有以下几个： 点击某个桌面应用中的取消按钮时； 某个操作超过了一定的执行时间限制需要中止时； 多个线程做相同的事情，只要一个线程成功其它线程都可以取消时； 一组线程中的一个或多个出现错误导致整组都无法继续时； 当一个应用或服务需要停止时。 Wait and Notify 在 Java 中可以用 wait/notify 来实现进程间的通信，一个经典的例子就是生产者和消费者模型。与 wait/notify 相关的函数有下面5个，这 5 个函数都是 Object 类中的方法，所以线程 wait 或者 notify 时都会关联一个相关的对象。 public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException { if (timeout 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos > 0) { timeout++; } wait(timeout); } public final void wait() throws InterruptedException { wait(0); } public final native void notify(); public final native void notifyAll(); 首先来说一下上述函数的功能： wait() - 使线程处于针对于当前对象的等待状态。通过另外一个线程调用等待对象的 notify() 或者 notifyAll() 方法可以唤醒等待的线程。wait 方法会抛出 InterruptedException，也就是说如果对等待线程调用 interrupt() 方法，也会使线程退出等待状态。在线程调用某个对象的 wait 方法之前，需要首先获得该对象的锁。当线程处于等待时会释放掉该对象的锁。当等待线程被唤醒之后需要重新获得等待对象的锁。处于等待状态的线程不会再占用 CPU 资源。 wait(long) / wait(long, int) - 超时等待，当超过预设的的时间之后即使没有 notify 或者 interrupt，线程也会退出等待状态。 notify() - 唤醒一个针对当前对象等待的线程，如果有多个线程正在等待当前对象，会随机选择一个唤醒。 notigyAll() - 唤醒所有针对当前对象等待的线程。 为什么线程在调用对象的 wait 或者 notify 方法之前需要首先获得对象锁呢？个人觉得主要原因就是为了确保某一个时间内只有一个线程执行该对象的 wait 或者 notify 方法。假设线程 1 正在执行 a.wait() ，随后线程 2 执行 a.notify()（线程 1 还没完成等待工作），线程 1 和 2 都没有获得对象锁，那么问题来了，因为线程 1 还没有完成等待的操作，那么线程 2 也就不知道线程 1 在等待，也就不会唤醒线程 1，当线程 1 完成等待操作之后，线程 2 也早已完成唤醒操作，线程 1 就会一直处于等待状态。 在 Java 中每个对象都有一个内置的锁，被称为 intrinsic lock 或者 monitor lock，Java 的 API 文档中经常把这个内置锁简称为 monitor。这里将其称为对象锁。获得对象锁的途径有下面三种（直接从 Javadoc 中抄的）： By executing a synchronized instance method of that object. By executing the body of a {@code synchronized} statement that synchronizes on the object. For objects of type {@code Class,} by executing a synchronized static method of that class. 也就是下面三种方式： // 该方法获得是当前对象的锁 public synchronized void method(){} // 该方法获得的是 Class 对象的锁 public synchronized static void staticMethod(){} // 该方法获得是 obj 对象的锁 synchronized (obj) { obj.notify(); } 所以我们看到在使用 wait 或者 notify 方法时，必定要和 synchronized 方法或者 synchronized 同步块相关联，诸如下面的形式： synchronized(obj) { obj.wait(); } public synchronized void method() throws InterruptedException { wait(); } 为了保证程序的正确性，我们也需要对象的修改做同步。如果同步对象修改和 wait/notify 之间有一定的关联，那么需要将这两个操作放到一个同步块中。例如生产者消费者模型中：生产者生产了商品需要唤醒消费者，就需要将生产商品和唤醒消费者的操作放到一个同步块中，如下面的形式。 // buffer 是共享变量 Queue buffer = new LinkedList (); public void method() { synchronized(buffer) { buffer.add(data); notify(); } } 假设对两者分别同步，如下面的代码： class BlockingQueue { Queue buffer = new LinkedList(); public void give(String data) { synchronized (buffer) { buffer.add(data); } synchronized (buffer) { notify(); } } public String take() throws InterruptedException { synchronized (buffer) { while (buffer.isEmpty()) wait(); } synchronized (buffer) { return buffer.remove(); } } } 对于上述代码，下面是有可能发生的情况： 一个消费者线程调用 take() 方法，发现 buffer 为空 在消费者线程调用 wait() 方法之前，生产者线程来了，它调用 give() 方法，生产东西放到了 buffer 里并调用 notify() 方法 此时消费者开始调用 wait() 方法，假设此后生产者线程都不再生产商品，即不在调用 give() 方法了，那么消费者线程将一直等待下去，即便有商品可用。 所以需要将共享变量的修改以及 wait/notify 调用放到同一个同步块中。 同时对于 wait 的条件判断，我们需要使用 while，而不是 if ，如下所示： synchronized(obj) { while (condition) { wait(); } } 这是因为线程可能存在 spurious wakeup，也就是说即便没有 notify , interrupt 或者超时，线程也有可能从 wait 的状态中醒过来。所以需要用 while 循环来判断是否需要线程再次进入 wait 状态。 关于 wait 和 notify 方法为什么会定义在 Object 类里，可以参考 这篇文章。 生产者消费者模式 http://www.infoq.com/cn/articles/producers-and-consumers-mode https://software.intel.com/zh-cn/blogs/2014/02/28/java http://blog.csdn.net/luohuacanyue/article/details/14648185 http://stackoverflow.com/questions/2779484/why-must-wait-always-be-in-synchronized-block http://www.jianshu.com/p/75d154292dcc 下面是生产者消费者的一个简单示例 import java.util.LinkedList; import java.util.Queue; public class ProducerConsumer { public static class Storage { private final int MAX_ITEM = 5; private Queue queue = new LinkedList<>(); public synchronized void put(Integer item) { while (queue.size() >= MAX_ITEM) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } queue.add(item); System.out.println(\"produce product: \" + item); notifyAll(); } public synchronized Integer take() { Integer item = 0; while (queue.isEmpty()) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // slow down the consumer speed. try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } item = queue.poll(); System.out.println(\"consume product: \" + item); notifyAll(); return item; } } public static class ProducerThread implements Runnable { private Storage storage; public ProducerThread(Storage storage) { this.storage = storage; } @Override public void run() { int num = 20; for (int i = 0; i Thread 方法 在 Thread 类中定义了一些其他的方法，下面介绍一下这些方法。 init 在运行线程之前首先构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，例如线程所属的线程组、线程优先级等信息。Thread 类通过一个私有的 init 方法，用来初始化线程，下面是代码： /** * Initializes a Thread. * * @param g the Thread group * @param target the object whose run() method gets called * @param name the name of the new Thread * @param stackSize the desired stack size for the new thread, or * zero to indicate that this parameter is to be ignored. * @param acc the AccessControlContext to inherit, or * AccessController.getContext() if null */ private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name.toCharArray(); // 当前正在运行的线程是新线程的父线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 在上面的过程中，一个新构造的线程对象是由其 Parent 线程来进行空间分配的，而 Child 线程继承了父线程是否为 Daemon、优先级和加载资源的 contextClassLoader以及可继承的 ThreadLocal，同时还会分配一个唯一的线程 ID （nextThreadID 方法，是一个 synchronized 方法）来标识这个Child 线程 start 通过调用 start 方法来启动一个线程，需要注意的是直接运行 run 方法是不会启动新的线程的。下面是 start 的代码，我们看到 start 方法其实是调用了一个 native 方法来启动线程的。 public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); join 如果线程 T 执行了 thread.join() 语句，那么线程 T 将等待 thread 线程执行完，再往下执行，下面是一个使用示例： public class JoinDemo { public static class JoinThread implements Runnable{ @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"in JoinThread\"); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new JoinThread()); thread.start(); System.out.println(\"in main thread: before thread.join()\"); thread.join(); System.out.println(\"in main thread: after thread.join()\"); } } 下面是 join 方法的实现： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } join(millis); } public final void join() throws InterruptedException { join(0); } public final native boolean isAlive(); 我们看到 join 实际上是调用了 wait 方法，wait 获得的对象锁就是 thread 对象，当 thread 执行完之后再唤醒 wait 方法（底层实现的）。 yield yield 是 Thread 类中的一个静态方法。yield 方法会给调度器发送一个暗示 （hint），告诉调度器当前线程将要让出 CPU 资源，让其他同优先级或者高优先级的线程来使用 CPU。使用这个方法有几点需要注意的地方： 调度器可以选择忽略 yield 发出的暗示。 不同的系统以及不同的 Java 版本对于 yield 的实现方法不同，具体的可以参考 这篇文章。在 Windows 的高版本 JDK 中（>=1.6），yield 只是将当前线程从运行状态 （running）变为就绪状态（ready），当前线程还是有可能再次竞争到 CPU 资源，再次执行。在 Linux 的实现中，需要其他线程都获得了 CPU 资源执行（不一定执行完）之后，被 yield 的线程才可以再次获取 CPU 资源。 Java 中的线程优先级也是个不靠谱的东西。 和线程优先级一样，程序的正确性不要依赖于 yield 方法。一般来说，yield 只用于调试。下面是一个示例： public class YieldDemo { public static class YieldThread implements Runnable { @Override public void run() { int num = 10; for (int i = 0; i currentThread 通过 currentThread 方法可以获得当前正在运行的线程，下面是获得主线程信息的一个例子： public class CurrentThreadDemo { public static void main(String[] args) { Thread thread = Thread.currentThread(); System.out.println(thread.getId() + \" \" + thread.getName()); } } 参考文章 Java 并发编程的艺术 Java 理论与实践: 处理 InterruptedException 详细分析Java中断机制 Concurrent Programming in Java 如何在 Java 中正确使用 wait, notify 和 notifyAll The Java™ Tutorials -- Concurrency Java - Multithreading Multithreading in java with examples "},"ThreadLocal.html":{"url":"ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 线程局部变量 使用示例 具体实现 ThreadLocalMap 散列表 实现 副本变量存取 ThreadLocal 散列值 应用场景 参考文章 线程局部变量 在多线程环境下，之所以会有并发问题，就是因为不同的线程会同时访问同一个共享变量，例如下面的形式 public class MultiThreadDemo { public static class Number { private int value = 0; public void increase() throws InterruptedException { value = 10; Thread.sleep(10); System.out.println(\"increase value: \" + value); } public void decrease() throws InterruptedException { value = -10; Thread.sleep(10); System.out.println(\"decrease value: \" + value); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread decreaseThread = new Thread(new Runnable() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }); increaseThread.start(); decreaseThread.start(); } } 在上面的代码中，increase 线程和 decrease 线程会操作同一个 number 中 value，那么输出的结果是不可预测的，因为当前线程修改变量之后但是还没输出的时候，变量有可能被另外一个线程修改，下面是一种可能的情况： increase value: 10 decrease value: 10 一种解决方法是在 increase() 和 decrease() 方法上加上 synchronized 关键字进行同步，这种做法其实是将 value 的 赋值 和 打印 包装成了一个原子操作，也就是说两者要么同时进行，要不都不进行，中间不会有额外的操作。我们换个角度考虑问题，如果 value 只属于 increase 线程或者 decrease 线程，而不是被两个线程共享，那么也不会出现竞争问题。一种比较常见的形式就是局部（local）变量（这里排除局部变量引用指向共享对象的情况），如下所示： public void increase() throws InterruptedException { int value = 10; Thread.sleep(10); System.out.println(\"increase value: \" + value); } 不论 value 值如何改变，都不会影响到其他线程，因为在每次调用 increase 方法时，都会创建一个 value 变量，该变量只对当前调用 increase 方法的线程可见。借助于这种思想，我们可以对每个线程创建一个共享变量的副本，该副本只对当前线程可见（可以认为是线程私有的变量），那么修改该副本变量时就不会影响到其他的线程。一个简单的思路是使用 Map 存储每个变量的副本，将当前线程的 id 作为 key，副本变量作为 value 值，下面是一个实现： public class SimpleImpl { public static class CustomThreadLocal { private Map cacheMap = new HashMap<>(); private int defaultValue ; public CustomThreadLocal(int value) { defaultValue = value; } public Integer get() { long id = Thread.currentThread().getId(); if (cacheMap.containsKey(id)) { return cacheMap.get(id); } return defaultValue; } public void set(int value) { long id = Thread.currentThread().getId(); cacheMap.put(id, value); } } public static class Number { private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException { value.set(10); Thread.sleep(10); System.out.println(\"increase value: \" + value.get()); } public void decrease() throws InterruptedException { value.set(-10); Thread.sleep(10); System.out.println(\"decrease value: \" + value.get()); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread decreaseThread = new Thread(new Runnable() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }); increaseThread.start(); decreaseThread.start(); } } 但是上面的实现会存在下面的问题： 每个线程对应的副本变量的生命周期不是由线程决定的，而是由共享变量的生命周期决定的。在上面的例子中，即便线程执行完，只要 number 变量存在，线程的副本变量依然会存在（存放在 number 的 cacheMap 中）。但是作为特定线程的副本变量，该变量的生命周期应该由线程决定，线程消亡之后，该变量也应该被回收。 多个线程有可能会同时操作 cacheMap，需要对 cacheMap 进行同步处理。 为了解决上面的问题，我们换种思路，每个线程创建一个 Map，存放当前线程中副本变量，用 CustomThreadLocal 的实例作为 key 值，下面是一个示例： public class SimpleImpl2 { public static class CommonThread extends Thread { Map cacheMap = new HashMap<>(); } public static class CustomThreadLocal { private int defaultValue; public CustomThreadLocal(int value) { defaultValue = value; } public Integer get() { Integer id = this.hashCode(); Map cacheMap = getMap(); if (cacheMap.containsKey(id)) { return cacheMap.get(id); } return defaultValue; } public void set(int value) { Integer id = this.hashCode(); Map cacheMap = getMap(); cacheMap.put(id, value); } public Map getMap() { CommonThread thread = (CommonThread) Thread.currentThread(); return thread.cacheMap; } } public static class Number { private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException { value.set(10); Thread.sleep(10); System.out.println(\"increase value: \" + value.get()); } public void decrease() throws InterruptedException { value.set(-10); Thread.sleep(10); System.out.println(\"decrease value: \" + value.get()); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new CommonThread() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }; Thread decreaseThread = new CommonThread() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }; increaseThread.start(); decreaseThread.start(); } } 在上面的实现中，当线程消亡之后，线程中 cacheMap 也会被回收，它当中存放的副本变量也会被全部回收，并且 cacheMap 是线程私有的，不会出现多个线程同时访问一个 cacheMap 的情况。在 Java 中，ThreadLocal 类的实现就是采用的这种思想，注意只是思想，实际的实现和上面的并不一样。 使用示例 Java 使用 ThreadLocal 类来实现线程局部变量模式，ThreadLocal 使用 set 和 get 方法设置和获取变量，下面是函数原型： public void set(T value); public T get(); 下面是使用 ThreadLocal 的一个完整示例： public class ThreadLocalDemo { private static ThreadLocal threadLocal = new ThreadLocal<>(); private static int value = 0; public static class ThreadLocalThread implements Runnable { @Override public void run() { threadLocal.set((int)(Math.random() * 100)); value = (int) (Math.random() * 100); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.printf(Thread.currentThread().getName() + \": threadLocal=%d, value=%d\\n\", threadLocal.get(), value); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new ThreadLocalThread()); Thread thread2 = new Thread(new ThreadLocalThread()); thread.start(); thread2.start(); thread.join(); thread2.join(); } } 下面是一种可能的输出： Thread-0: threadLocal=87, value=15 Thread-1: threadLocal=69, value=15 我们看到虽然 threadLocal 是静态变量，但是每个线程都有自己的值，不会受到其他线程的影响。 具体实现 ThreadLocal 的实现思想，我们在前面已经说了，每个线程维护一个 ThreadLocalMap 的映射表，映射表的 key 是 ThreadLocal 实例本身，value 是要存储的副本变量。ThreadLocal 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。 如下图所示： 图片来自 http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/ 我们从下面三个方面看下 ThreadLocal 的实现： 存储线程副本变量的数据结构 如何存取线程副本变量 如何对 ThreadLocal 的实例进行 Hash ThreadLocalMap 线程使用 ThreadLocalMap 来存储每个线程副本变量，它是 ThreadLocal 里的一个静态内部类。ThreadLocalMap 也是采用的散列表（Hash）思想来实现的，但是实现方式和 HashMap 不太一样。我们首先看下散列表的相关知识： 散列表 理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图： 图片来自 数据结构与算法分析: C语法描述 在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式： 分离链表法（separate chaining） 开放定址法（open addressing） 分离链表法分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。下面是一个示意图： 图片来自 http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm 开放定址法开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 -- 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示： 图片来自 http://alexyyek.github.io/2014/12/14/hashCollapse/ 关于两种方式的比较，可以参考 这篇文章。ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。 实现 我们知道 Map 是一种 key-value 形式的数据结构，所以在散列数组中存储的元素也是 key-value 的形式。ThreadLocalMap 使用 Entry 类来存储数据，下面是该类的定义： static class Entry extends WeakReference > { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) { super(k); value = v; } } Entry 将 ThreadLocal 实例作为 key，副本变量作为 value 存储起来。注意 Entry 中对于 ThreadLocal 实例的引用是一个弱引用，该引用定义在 Reference 类（WeakReference的父类）中，下面是 super(k) 最终调用的代码： Reference(T referent) { this(referent, null); } Reference(T referent, ReferenceQueue queue) { this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue; } 关于弱引用和为什么使用弱引用可以参考 Java 理论与实践: 用弱引用堵住内存泄漏 和 深入分析 ThreadLocal 内存泄漏问题。下面看一下 ThreadLocalMap 的 set 函数 private void set(ThreadLocal key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置 int i = key.threadLocalHashCode & (len - 1); // 使用线性探测法查找元素 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); // ThreadLocal 对应的 key 存在，直接覆盖之前的值 if (k == key) { e.value = value; return; } // key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前数组中的 Entry 是一个陈旧（stale）的元素 if (k == null) { // 用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏，具体可以看源代码，没看太懂 replaceStaleEntry(key, value, i); return; } } // ThreadLocal 对应的 key 不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的 Entry。 tab[i] = new Entry(key, value); int sz = ++size; // cleanSomeSlot 清理陈旧的 Entry（key == null），具体的参考源码。如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash。 if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } 关于 set 方法，有几点需要地方： int i = key.threadLocalHashCode & (len - 1);，这里实际上是对 len-1 进行了取余操作。之所以能这样取余是因为 len 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。 在 replaceStaleEntry 和 cleanSomeSlots 方法中都会清理一些陈旧的 Entry，防止内存泄漏 threshold 的值大小为 threshold = len * 2 / 3; rehash 方法中首先会清理陈旧的 Entry，如果清理完之后元素数量仍然大于 threshold 的 3/4，则进行扩容操作（数组大小变为原来的 2倍）private void rehash() { expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } 我们再看一下 getEntry （没有 get 方法，就叫 getEntry）方法： private Entry getEntry(ThreadLocal key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } 因为 ThreadLocalMap 中采用开放定址法，所以当前 key 的散列值和元素在数组中的索引并不一定完全对应。所以在 get 的时候，首先会看 key 的散列值对应的数组元素是否为要查找的元素，如果不是，再调用 getEntryAfterMiss 方法查找后面的元素。 private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } 最后看一下删除操作。删除其实就是将 Entry 的键值设为 null，变为陈旧的 Entry。然后调用 expungeStaleEntry 清理陈旧的 Entry。 private void remove(ThreadLocal key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len - 1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } 副本变量存取 前面说完了 ThreadLocalMap，副本变量的存取操作就很好理解了。下面是 ThreadLocal 中的 set 和 get 方法的实现： public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T) e.value; return result; } } return setInitialValue(); } 存取的基本流程就是首先获得当前线程的 ThreadLocalMap，将 ThreadLocal 实例作为键值传入 Map，然后就是进行相关的变量存取工作了。线程中的 ThreadLocalMap 是懒加载的，只有真正的要存变量时才会调用 createMap 创建，下面是 createMap 的实现： void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } 如果想要给 ThreadLocal 的副本变量设置初始值，需要重写 initialValue 方法，如下面的形式： ThreadLocal threadLocal = new ThreadLocal() { protected Integer initialValue() { return 0; } }; ThreadLocal 散列值 当创建了一个 ThreadLocal 的实例后，它的散列值就已经确定了，下面是 ThreadLocal 中的实现： /** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */ private final int threadLocalHashCode = nextHashCode(); /** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); /** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; /** * Returns the next hash code. */ private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } 我们看到 threadLocalHashCode 是一个常量，它通过 nextHashCode() 函数产生。nextHashCode() 函数其实就是在一个 AtomicInteger 变量（初始值为0）的基础上每次累加 0x61c88647，使用 AtomicInteger 为了保证每次的加法是原子操作。而 0x61c88647 这个就比较神奇了，它可以使 hashcode 均匀的分布在大小为 2 的 N 次方的数组里。下面写个程序测试一下: public static void main(String[] args) { AtomicInteger hashCode = new AtomicInteger(); int hash_increment = 0x61c88647; int size = 16; List list = new ArrayList <> (); for (int i = 0; i 我们将 size 设为 16，32 和 64 分别测试一下： // size=16 original:[0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] // size=32 original:[0, 7, 14, 21, 28, 3, 10, 17, 24, 31, 6, 13, 20, 27, 2, 9, 16, 23, 30, 5, 12, 19, 26, 1, 8, 15, 22, 29, 4, 11, 18, 25] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31] // size=64 original:[0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 6, 13, 20, 27, 34, 41, 48, 55, 62, 5, 12, 19, 26, 33, 40, 47, 54, 61, 4, 11, 18, 25, 32, 39, 46, 53, 60, 3, 10, 17, 24, 31, 38, 45, 52, 59, 2, 9, 16, 23, 30, 37, 44, 51, 58, 1, 8, 15, 22, 29, 36, 43, 50, 57] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63] 可以看到随着 size 的变化，hashcode 总能均匀的分布。其实这就是 Fibonacci Hashing，具体可以参考 这篇文章。所以虽然 ThreadLocal 的 hashcode 是固定的，当 ThreadLocalMap 中的散列表调整大小（变为原来的 2 倍）之后重新散列，hashcode 仍能均匀的分布在散列表中。 应用场景 摘自 Java并发编程：深入剖析ThreadLocal 最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如 private static ThreadLocal connectionHolder = new ThreadLocal () { public Connection initialValue() { return DriverManager.getConnection(DB_URL); } }; public static Connection getConnection() { return connectionHolder.get(); } private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } 参考文章 http://www.iteye.com/topic/103804 http://www.jianshu.com/p/529c03d9b67e http://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java http://jerrypeng.me/2013/06/thread-local-and-magical-0x61c88647/ ThreadLocal是否会引发内存泄露的分析（转） [Java并发包学习七]解密ThreadLocal 数据结构与算法分析: C语法描述 "},"显式锁.html":{"url":"显式锁.html","title":"显式锁","keywords":"","body":"显示锁 公平锁 非公平锁 自旋锁 可重入锁 偏向锁 轻量级锁 重量级锁 轻量级锁 读写锁 互斥锁 锁消除 锁粗化 悲观锁 乐观锁 共享锁 排他锁 "},"Lock框架.html":{"url":"Lock框架.html","title":"Lock 框架","keywords":"","body":"Lock 框架 示例 Lock 框架体系 参考资料 示例 通过使用显式锁，我们可以更加灵活的来处理线程同步。同时使用显式锁可以实现 synchronized 所没有的功能，下面是使用显式锁的一个示例： import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Created by Jikai Zhang on 2017/4/4. */ public class ReentrantLockTest { private static int count = 1; private static Lock lock = new ReentrantLock(); static class CustomThread implements Runnable { @Override public void run() { lock.lock(); try { count++; Thread.sleep(1000); System.out.println(Thread.currentThread().toString() + \": \" + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } public static void main(String[] args) { Thread thread = new Thread(new CustomThread()); Thread thread2 = new Thread(new CustomThread()); thread.start(); thread2.start(); } } Lock 框架体系 图片来自 https://my.oschina.net/xianggao/blog/88477 参考资料 Java 并发：Lock 框架详解 Java Threads Java Concurrency / Multithreading Tutorial "},"AbstractQueuedSynchronizer.html":{"url":"AbstractQueuedSynchronizer.html","title":"AbstractQueuedSynchronizer","keywords":"","body":"队列同步器 前言 AQS 和 synchronized 基本使用 CAS 操作 同步队列 Node 类 独占锁的获取和释放 共享锁获取和释放 参考文章 前言 队列同步器 AbstractQueuedSynchronizer（以下简称 AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个 int 成员变量来表示同步状态，通过 CAS 操作对同步状态进行修改，确保状态的改变是安全的。通过内置的 FIFO （First In First Out）队列来完成资源获取线程的排队工作。 AQS 和 synchronized 在介绍 AQS 的使用之前，需要首先说明一点，AQS 同步和 synchronized 关键字同步（以下简称 synchronized 同步）是采用的两种不同的机制。首先看下 synchronized 同步，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码需要关联到一个监视对象，当线程执行 monitorenter 指令时，需要首先获得获得监视对象的锁，这里监视对象锁就是进入同步块的凭证，只有获得了凭证才可以进入同步块，当线程离开同步块时，会执行 monitorexit 指令，释放对象锁。 在 AQS 同步中，使用一个 int 类型的变量 state 来表示当前同步块的状态。以独占式同步（一次只能有一个线程进程同步块）为例，state 的有效值有两个 0 和 1，其中 0 表示当前同步块中没有线程，1 表示同步块中已经有线程在执行。当线程要进入同步块时，需要首先判断 state 的值是否为 0，假设为 0，会尝试将 state 修改为 1，只有修改成功了之后，线程才可以进入同步块。注意上面提到的两个条件： state 为 0，证明当前同步块中没有线程在执行，所以当前线程可以尝试获得进入同步块的凭证，而这里的凭证就是是否成功将 state 修改为 1（在 synchronized 同步中，我们说的凭证是对象锁，但是对象锁的最终实现是否和我们现在说的方式类似，这里没有找到相关的资料） 成功将 state 修改为 1，通过使用 CAS 操作，我们可以确保即便有多个线程同时修改 state，也只有一个线程会修改成功。关于 CAS 的具体解释会在后面提到。 当线程离开同步块时，会修改 state 的值，将其设为 0，并唤醒等待的线程。所在在 AQS 同步中，我们说线程获得了锁，实际上是指线程成功修改了状态变量 state，而线程释放了锁，是指线程将状态变量置为了可修改的状态（在独占式同步中就是置为了 0），让其他线程可以再次尝试修改状态变量。在下面的表述中，我们说线程获得和释放了锁，就是上述含义， 这与 synchronized 同步中说的获得和释放锁的含义不同，需要区别理解。 基本使用 AQS 的设计是基于模板方法的，使用者需要继承 AQS 并重写指定的方法。在随后的使用中，AQS 中的模板方法会调用重写的方法。一般来说，我们需要重写的方法主要有下面 5 个： 方法名称 描述 protected boolean tryAcquire(int) 独占式获取锁，实现该方法需要查询当前状态并判断同步状态是否和预期值相同，然后使用 CAS 操作设置同步状态 protected boolean tryRelease(int) 独占式释放锁，等待获取锁的线程将有机会获取锁 protected int tryAcquireShared(int) 共享式获取锁，返回大于等于 0 的值，表示获取锁成功，反之获取失败 protected boolean tryReleaseShared(int) 共享式释放锁 protected boolean isHeldExclusively() 判断当前线程是否占有独占锁 在自定义的同步组件中，我们一般会调用 AQS 提供的模板方法。AQS 提供的模板方法基本上分为 3 类： 独占式获取与释放锁、共享式获取与释放锁以及查询同步队列中的等待线程情况。下面是相关的模板方法： 方法名称 描述 void acquire(int) 独占式获取锁，如果当前线程成功获取锁，那么方法就返回，否则会将当前线程放入同步队列等待。该方法会调用重写的 tryAcquire(int arg) 方法判断是否可以获得锁 void acquireInterruptibly(int) 和 acquire(int) 相同，但是该方法响应中断，当线程在同步队列中等待时，如果线程被中断，会抛出 InterruptedException 异常并返回。 boolean tryAcquireNanos(int, long) 在 acquireInterruptibly(int) 基础上添加了超时控制，同时支持中断和超时，当在指定时间内没有获得锁时，会返回 false，获取到了返回 true void acquireShared(int) 共享式获得锁，如果成功获得锁就返回，否则将当前线程放入同步队列等待，与独占式获取锁的不同是，同一时刻可以有多个线程获得共享锁，该方法调用 tryAcquireShared(int) acquireSharedInterruptibly(int) 与 acquireShared(int) 相同，该方法响应中断 tryAcquireSharedNanos(int, long) 在 acquireSharedInterruptibly(int) 基础上添加了超时控制 boolean release(int) 独占式释放锁，该方法会在释放锁后，将同步队列中的第一个节点包含的线程唤醒 boolean releaseShared(int) 共享式释放锁 Collection getQueuedThreads() 获得同步队列中等待的线程集合 自定义组件通过使用使用同步器提供的模板方法来实现自己的同步语义。下面我们通过两个示例，看下如何借助于 AQS 来实现锁的同步语义。我们首先实现一个独占锁（排它锁），独占锁就是说在某个时刻内，只能有一个线程持有独占锁，只有持有锁的线程释放了独占锁，其他线程可以获取独占锁。下面是具体实现： import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.AbstractQueuedLongSynchronizer; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; /** * Created by Jikai Zhang on 2017/4/6. * * 自定义独占锁 */ public class Mutex implements Lock { // 通过继承 AQS，自定义同步器 private static class Sync extends AbstractQueuedLongSynchronizer { // 当前线程是否被独占 @Override protected boolean isHeldExclusively() { return getState() == 1; } // 尝试获得锁 @Override protected boolean tryAcquire(long arg) { // 只有当 state 的值为 0，并且线程成功将 state 值修改为 1 之后，线程才可以获得独占锁 if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } @Override protected boolean tryRelease(long arg) { // state 为 0 说明当前同步块中没有锁了，无需释放 if (getState() == 0) { throw new IllegalMonitorStateException(); } // 将独占的线程设为 null setExclusiveOwnerThread(null); // 将状态变量的值设为 0，以便其他线程可以成功修改状态变量从而获得锁 setState(0); return true; } Condition newCondition() { return new ConditionObject(); } } // 将操作代理到 Sync 上 private final Sync sync = new Sync(); @Override public void lock() { sync.acquire(1); } @Override public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } @Override public boolean tryLock() { return sync.tryAcquire(1); } @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(time)); } @Override public void unlock() { sync.release(1); } @Override public Condition newCondition() { return sync.newCondition(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public boolean isLocked() { return sync.isHeldExclusively(); } public static void withoutMutex() throws InterruptedException { System.out.println(\"Without mutex: \"); int threadCount = 2; final Thread threads[] = new Thread[threadCount]; for (int i = 0; i 程序的运行结果如下面所示。我们看到使用了 Mutex 之后，线程 0 和线程 1 不会再交替执行，而是当一个线程执行完，另外一个线程再执行。 Without mutex: Thread-0: j =0 Thread-1: j =0 Thread-0: j =20000 Thread-1: j =20000 Thread-0: j =40000 Thread-1: j =40000 Thread-0: j =60000 Thread-1: j =60000 Thread-1: j =80000 Thread-0: j =80000 With mutex: Thread-0: j =0 Thread-0: j =20000 Thread-0: j =40000 Thread-0: j =60000 Thread-0: j =80000 Thread-1: j =0 Thread-1: j =20000 Thread-1: j =40000 Thread-1: j =60000 Thread-1: j =80000 下面在看一个共享锁的示例。在该示例中，我们定义两个共享资源，即同一时间内允许两个线程同时执行。我们将同步变量的初始状态 state 设为 2，当一个线程获取了共享锁之后，将 state 减 1，线程释放了共享锁后，将 state 加 1。状态的合法范围是 0、1 和 2，其中 0 表示已经资源已经用光了，此时线程再要获得共享锁就需要进入同步序列等待。下面是具体实现： import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.AbstractQueuedSynchronizer; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; /** * Created by Jikai Zhang on 2017/4/9. * * 自定义共享锁 */ public class TwinsLock implements Lock { private static class Sync extends AbstractQueuedSynchronizer { public Sync(int resourceCount) { if (resourceCount = 0; } @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(time)); } @Override public void unlock() { sync.releaseShared(1); } @Override public Condition newCondition() { throw new UnsupportedOperationException(); } public static void main(String[] args) { final Lock lock = new TwinsLock(); int threadCounts = 10; Thread threads[] = new Thread[threadCounts]; for (int i = 0; i 运行程序，我们会发现程序每次都会同时打印两条语句，如下面的形式，证明同时有两个线程在执行。 Thread-0 Thread-1 Thread-3 Thread-2 Thread-8 Thread-4 Thread-3 Thread-6 CAS 操作 CAS（Compare and Swap），比较并交换，通过利用底层硬件平台的特性，实现原子性操作。CAS 操作涉及到3个操作数，内存值 V，旧的期望值 A，需要修改的新值 B。当且仅当预期值 A 和 内存值 V 相同时，才将内存值 V 修改为 B，否则什么都不做。CAS 操作类似于执行了下面流程 if(oldValue == memory[valueAddress]) { memory[valueAddress] = newValue; } 在上面的流程中，其实涉及到了两个操作，比较以及替换，为了确保程序正确，需要确保这两个操作的原子性（也就是说确保这两个操作同时进行，中间不会有其他线程干扰）。现在的 CPU 中，提供了相关的底层 CAS 指令，即 CPU 底层指令确保了比较和交换两个操作作为一个原子操作进行（其实在这一点上还是有排他锁的. 只是比起用synchronized, 这里的排他时间要短的多.），Java 中的 CAS 函数是借助于底层的 CAS 指令来实现的。更多关于 CPU 底层实现的原理可以参考 这篇文章。我们来看下 Java 中对于 CAS 函数的定义： /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x); /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x); 上面三个函数定义在 sun.misc.Unsafe 类中，使用该类可以进行一些底层的操作，例如直接操作原生内存，更多关于 Unsafe 类的文章可以参考 这篇。以 compareAndSwapInt 为例，我们看下如何使用 CAS 函数： import sun.misc.Unsafe; import java.lang.reflect.Field; /** * Created by Jikai Zhang on 2017/4/8. */ public class CASIntTest { private volatile int count = 0; private static final Unsafe unsafe = getUnsafe(); private static final long offset; // 获得 count 属性在 CASIntTest 中的偏移量（内存地址偏移） static { try { offset = unsafe.objectFieldOffset(CASIntTest.class.getDeclaredField(\"count\")); } catch (NoSuchFieldException e) { throw new Error(e); } } // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() { Unsafe unsafe = null; try { Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return unsafe; } public void increment() { int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); } public static void main(String[] args) { CASIntTest casIntTest = new CASIntTest(); casIntTest.increment(); System.out.println(casIntTest.count); } } 在 CASIntTest 类中，我们定义一个 count 变量，其中 increment() 方法是将 count 的值加 1，执行上面的程序，我们会看到输出结果也为 1。下面是将 count 加 1 的代码： int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); 在没有线程竞争的条件下，该代码执行的结果是将 count 变量的值加 1（多个线程竞争可能会有线程执行失败），但是在 compareAndSwapInt 函数中，我们并没有传入 count 变量，那么函数是如何修改 count 变量值的呢？其实我们往 compareAndSwapInt 函数中传入了 count 变量在堆内存中的地址，函数直接修改了 count 变量所在内存区域。count 属性在堆内存中的地址是由 CASIntTest 实例的起始内存地址和 count 属性相对于起始内存的偏移量决定的。其中对象属性在对象中的偏移量通过 objectFieldOffset 函数获得，函数原型如下所示。该函数接受一个 Filed 类型的参数，返回该 Filed 属性在对象中的偏移量。 /** * Report the location of a given static field, in conjunction with {@link * #staticFieldBase}. * Do not expect to perform any sort of arithmetic on this offset; * it is just a cookie which is passed to the unsafe heap memory accessors. * * Any given field will always have the same offset, and no two distinct * fields of the same class will ever have the same offset. * * As of 1.4.1, offsets for fields are represented as long values, * although the Sun JVM does not use the most significant 32 bits. * It is hard to imagine a JVM technology which needs more than * a few bits to encode an offset within a non-array object, * However, for consistency with other methods in this class, * this method reports its result as a long value. */ public native long objectFieldOffset(Field f); 下面我们再看一下 compareAndSwapInt 的函数原型。我们知道 CAS 操作需要知道 3 个信息：内存中的值，期望的旧值以及要修改的新值。通过前面的分析，我们知道通过 o 和 offset 我们可以确定属性在内存中的地址，也就是知道了属性在内存中的值。expected 对应期望的旧址，而 x 就是要修改的新值。 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); compareAndSwapInt 函数首先比较一下 expected 是否和内存中的值相同，如果不同证明其他线程修改了属性值，那么就不会执行更新操作，但是程序如果就此返回了，似乎不太符合我们的期望，我们是希望程序可以执行更新操作的，如果其他线程先进行了更新，那么就在更新后的值的基础上进行修改，所以我们一般使用循环配合 CAS 函数，使程序在更新操作完成之后再返回，如下所示： long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) { before = counter; } 下面是使用 CAS 函数实现计数器的一个实例： import sun.misc.Unsafe; import java.lang.reflect.Field; /** * Created by Jikai Zhang on 2017/4/8. */ public class CASCounter { // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() { Unsafe unsafe = null; try { Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return unsafe; } private volatile long counter = 0; private static final long offset; private static final Unsafe unsafe = getUnsafe(); static { try { offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(\"counter\")); } catch (NoSuchFieldException e) { throw new Error(e); } } public void increment() { long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) { before = counter; } } public long getCounter() { return counter; } private static long intCounter = 0; public static void main(String[] args) throws InterruptedException { int threadCount = 10; Thread threads[] = new Thread[threadCount]; final CASCounter casCounter = new CASCounter(); for (int i = 0; i 同步队列 同步器依赖内部的同步队列（一个 FIFO）的双向队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。同步队列的结构如下所示： 图片来自 http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer Head 节点本身不保存等待线程的信息，它通过 next 变量指向第一个保存线程等待信息的节点（Node1）。当线程被唤醒之后，会删除 Head 节点，而唤醒线程所在的节点会设置为 Head 节点（Node1 被唤醒之后，Node1会被置为 Head 节点）。下面我们看下 JDK 中同步队列的实现。 Node 类 首先看在节点所对应的 Node 类： static final class Node { /** * 标志是独占式模式还是共享模式 */ static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; /** * 线程等待状态的合法值 */ static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; /** * 线程状态，合法值为上面 4 个值中的一个 */ volatile int waitStatus; /** * 当前节点的前置节点 */ volatile Node prev; /** * 当前节点的后置节点 */ volatile Node next; /** * 当前节点所关联的线程 */ volatile Thread thread; /** * 指向下一个在某个条件上等待的节点，或者指向 SHARE 节点，标明当前处于共享模式 */ Node nextWaiter; final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // Used to establish initial head or SHARED marker } Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } } 在 Node 类中定义了四种等待状态： CANCELED： 1，因为等待超时 （timeout）或者中断（interrupt），节点会被置为取消状态。处于取消状态的节点不会再去竞争锁，也就是说不会再被阻塞。节点会一直保持取消状态，而不会转换为其他状态。处于 CANCELED 的节点会被移出队列，被 GC 回收。 SIGNAL： -1，标明当前的后继结点正在或者将要被阻塞（通过使用 LockSupport.pack 方法）。因为当前的节点被释放（release）或者被取消时（cancel）时，要唤醒它的后继结点（通过 LockSupport.unpark 方法）。 CONDITION： -2，标明当前节点在条件队列中，因为等待某个条件而被阻塞。 PROPAGATE： -3，在共享模式下，可以认为资源有多个，因此当前线程被唤醒之后，可能还有剩余的资源可以唤醒其他线程。该状态用来标明后续节点会传播唤醒的操作。需要注意的是只有头节点才可以设置为该状态（This is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened.）。 0：新创建的节点会处于这种状态 独占锁的获取和释放 我们首先看下独占锁的获取和释放过程 独占锁获取 下面是获取独占锁的流程图： 我们通过 acquire 方法来获取独占锁，下面是方法定义 public final void acquire(int arg) { // 首先尝试获取锁，如果获取失败，会先调用 addWaiter 方法将创建节点并追加到队列尾部 // 然后调用 acquireQueued 阻塞或者循环尝试获取锁 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)){ // 在 acquireQueued 中，如果线程是因为中断而退出的阻塞状态会返回 true // 这里的 selfInterrupt 主要是为了恢复线程的中断状态 selfInterrupt(); } } acquire 会首先调用 tryAcquire 方法来获得锁，这个方法需要我们来实现，这个在前面已经提过了。如果没有获取锁，会调用 addWaiter 方法会创建一个和当前线程关联的节点追加到同步队列的尾部，我们调用 addWaiter 时传入的是 Node.EXCLUSIVE，表明当前是独占模式。下面是 addWaiter 的具体实现 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // tail 指向同步队列的尾节点 Node pred = tail; // Try the fast path of enq; backup to full enq on failure if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } addWaiter 方法会首先调用 if 方法，来判断能否成功将节点添加到队列尾部，如果添加失败，再调用 enq 方法（使用循环不断重试）进行添加，下面是 enq 方法的实现： private Node enq(final Node node) { for (;;) { Node t = tail; // 同步队列采用的懒初始化（lazily initialized）的方式， // 初始时 head 和 tail 都会被设置为 null，当一次被访问时 // 才会创建 head 对象，并把尾指针指向 head。 if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } addWaiter 仅仅是将节点加到了同步队列的末尾，并没有阻塞线程，线程阻塞的操作是在 acquireQueued 方法中完成的，下面是 acquireQueued 的实现： final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); // 如果当前节点的前继节点是 head，就使用自旋（循环）的方式不断请求锁 if (p == head && tryAcquire(arg)) { // 成功获得锁，将当前节点置为 head 节点，同时删除原 head 节点 setHead(node); p.next = null; // help GC failed = false; return interrupted; } // shouldParkAfterFailedAcquire 检查是否可以挂起线程， // 如果可以挂起进程，会调用 parkAndCheckInterrupt 挂起线程， // 如果 parkAndCheckInterrupt 返回 true，表明当前线程是因为中断而退出挂起状态的， // 所以要将 interrupted 设为 true，表明当前线程被中断过 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } acquireQueued 会首先检查当前节点的前继节点是否为 head，如果为 head，将使用自旋的方式不断的请求锁，如果不是 head，则调用 shouldParkAfterFailedAcquire 查看是否应该挂起当前节点关联的线程，下面是 shouldParkAfterFailedAcquire 的实现： private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 当前节点的前继节点的等待状态 int ws = pred.waitStatus; // 如果前继节点的等待状态为 SIGNAL 我们就可以将当前节点对应的线程挂起 if (ws == Node.SIGNAL) return true; if (ws > 0) { // ws 大于 0，表明当前线程的前继节点处于 CANCELED 的状态， // 所以我们需要从当前节点开始往前查找，直到找到第一个不为 // CAECELED 状态的节点 do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } shouldParkAfterFailedAcquire 会检查前继节点的等待状态，如果前继节点状态为 SIGNAL，则可以将当前节点关联的线程挂起，如果不是 SIGNAL，会做一些其他的操作，在当前循环中不会挂起线程。如果确定了可以挂起线程，就调用 parkAndCheckInterrupt 方法对线程进行阻塞： private final boolean parkAndCheckInterrupt() { // 挂起当前线程 LockSupport.park(this); // 可以通过调用 interrupt 方法使线程退出 park 状态， // 为了使线程在后面的循环中还可以响应中断，会重置线程的中断状态。 // 这里使用 interrupted 会先返回线程当前的中断状态，然后将中断状态重置为 false， // 线程的中断状态会返回给上层调用函数，在线程获得锁后， // 如果发现线程曾被中断过，会将中断状态重新设为 true return Thread.interrupted(); } 独占锁释放 下面是释放独占锁的流程： 通过 release 方法，我们可以释放互斥锁。下面是 release 方法的实现： public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; // waitStatus 为 0，证明是初始化的空队或者后继结点已经被唤醒了 if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 在独占模式下释放锁时，是没有其他线程竞争的，所以处理会简单一些。首先尝试释放锁，如果失败就直接返回（失败不是因为多线程竞争，而是线程本身就不拥有锁）。如果成功的话，会检查 h 的状态，然后调用 unparkSuccessor 方法来唤醒后续线程。下面是 unparkSuccessor 的实现： private void unparkSuccessor(Node node) { int ws = node.waitStatus; // 将 head 节点的状态置为 0，表明当前节点的后续节点已经被唤醒了， // 不需要再次唤醒，修改 ws 状态主要作用于 release 的判断 if (ws 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus 在 unparkSuccessor 方法中，如果发现头节点的后继结点为 null 或者处于 CANCELED 状态，会从尾部往前找（在节点存在的前提下，这样一定能找到）离头节点最近的需要唤醒的节点，然后唤醒该节点。 共享锁获取和释放 独占锁的流程和原理比较容易理解，因为只有一个锁，但是共享锁的处理将相对复杂一些了。在独占锁中，只有在释放锁之后，才能唤醒等待的线程，而在共享模式中，获取锁和释放锁之后，都有可能唤醒等待的线程。如果想要理清共享锁的工作过程，必须将共享锁的获取和释放结合起来看。这里我们先看一下共享锁的释放过程，只有明白了释放过程做了哪些工作，才能更好的理解获取锁的过程。 共享锁释放 通过 releaseShared 方法会释放共享锁，下面是具体的实现： public final boolean releaseShared(int releases) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } releases 是要释放的共享资源数量，其中 tryReleaseShared 的方法由我们自己重写，该方法的主要功能就是修改共享资源的数量（state + releases），因为可能会有多个线程同时释放资源，所以实现的时候，一般采用循环加 CAS 操作的方式，如下面的形式： protected boolean tryReleaseShared(int releases) { // 释放共享资源，因为可能有多个线程同时执行，所以需要使用 CAS 操作来修改资源总数。 for (;;) { int lastCount = getState(); int newCount = lastCount + releases; if (compareAndSetState(lastCount, newCount)) { return true; } } } 当共享资源数量修改了之后，会调用 doReleaseShared 方法，该方法主要唤醒同步队列中的第一个等待节点（head.next），下面是具体实现： private void doReleaseShared() { /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) { Node h = head; // head = null 说明没有初始化，head = tail 说明同步队列中没有等待节点 if (h != null && h != tail) { // 查看当前节点的等待状态 int ws = h.waitStatus; // 我们在前面说过，SIGNAL说明有后续节点需要唤醒 if (ws == Node.SIGNAL) { /* * 将当前节点的值设为 0，表明已经唤醒了后继节点 * 可能会有多个线程同时执行到这一步，所以使用 CAS 保证只有一个线程能修改成功， * 执行 unparkSuccessor，其他的线程会执行 continue 操作 */ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) { /* * ws 等于 0，说明无需唤醒后继结点（后续节点已经被唤醒或者当前节点没有被阻塞的后继结点）， * 也就是这一次的调用其实并没有执行唤醒后继结点的操作。就类似于我只需要一张优惠券， * 但是我的两个朋友，他们分别给我了一张，因此我就剩余了一张。然后我就将这张剩余的优惠券 * 送（传播）给其他人使用，因此这里将节点置为可传播的状态（PROPAGATE） */ continue; // loop on failed CAS } } if (h == head) // loop if head changed break; } } 从上面的实现中，doReleaseShared 的主要作用是用来唤醒阻塞的节点并且一次只唤醒一个，让该节点关联的线程去重新竞争锁，它既不修改同步队列，也不修改共享资源。 当多个线程同时释放资源时，可以确保两件事： 共享资源的数量能正确的累加 至少有一个线程被唤醒，其实只要确保有一个线程被唤醒就可以了，即便唤醒了多个线程，在同一时刻，也只能有一个线程能得到竞争锁的资源，在下面我们会看到。 所以释放锁做的主要工作还是修改共享资源的数量。而有了多个共享资源后，如何确保同步队列中的多个节点可以获取锁，是由获取锁的逻辑完成，下面看下共享锁的获取。 共享锁的获取 根据前面的内容，我们知道获取了共享锁之后，还可能需要唤醒后面的节点。下面看下具体的实现，通过 acquireShared 方法，我们可以申请共享锁，下面是具体的实现： public final void acquireShared(int arg) { // 如果返回结果小于 0，证明没有获取到共享资源 if (tryAcquireShared(arg) 如果没有获取到共享资源，就会执行 doAcquireShared 方法，下面是该方法的具体实现： private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r >= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 从上面的代码中可以看到，只有前置节点为 head 的节点才有可能去竞争锁，这点和独占模式的处理是一样的，所以即便唤醒了多个线程，也只有一个线程能进入竞争锁的逻辑，其余锁会再次进入 park 状态，获取当线程获取到共享锁之后，会执行 setHeadAndPropagate 方法，下面是具体的实现： private void setHeadAndPropagate(Node node, long propagate) { // 备份一下头节点 Node h = head; // Record old head for check below /* * 移除头节点，并将当前节点置为头节点 * 当执行完这一步之后，其实队列的头节点已经发生改变， * 其他被唤醒的线程就有机会去获取锁，从而并发的执行该方法， * 所以上面备份头节点，以便下面的代码可以正确运行 */ setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ /* * 判断是否需要唤醒后继结点，propagate > 0 说明共享资源有剩余， * h.waitStatus 0 || h == null || h.waitStatus 判断后继结点是否需要唤醒的条件是十分宽松的，也就是一定包含必要的唤醒，但是也有可能会包含不必要的唤醒。从前面我们可以知道 doReleaseShared 函数的主要作用是唤醒后继结点，它既不修改共享资源，也不修改同步队列，所以即便有不必要的唤醒也是不响应程序正确性的，如果没有共享资源，节点会再次进入等待状态。 到了这里，脉络就比较清晰了，当一个节点获取到共享锁之后，它除了将自身设为 head 节点之外，还会判断一下是否满足唤醒后继结点的条件，如果满足，就唤醒后继结点，后继结点获取到锁之后，会重复这个过程，直到判断条件不成立。就类似于考试时从第一排往最后一排从卷子一样，第一排先留下一份，然后将剩余的传给后一排，后一排会重复这个过程。如果传到某一排卷子没了，那么位于这排的人就要等待，知道老师又给了他新的卷子。 参考文章 Java 并发编程的艺术 Java Magic. Part 4: sun.misc.Unsafe Java里的CompareAndSet(CAS) ReentrantLock的lock-unlock流程详解 深入JVM锁机制2-Lock 深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上） http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-AbstractQueuedSynchronizer.html http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer https://my.oschina.net/xianggao/blog/532709 http://www.javarticles.com/2012/10/abstractqueuedsynchronizer-aqs.html http://www.mamicode.com/info-detail-5918.html "}}