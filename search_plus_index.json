{"./":{"url":"./","title":"前言","keywords":"","body":"Java 并发编程学习笔记 参考资料: Java 并发编程实战 Java 并发编程的艺术 Java并发性和多线程 The Java™ Tutorials 说明 使用的 JDK 版本为 1.8.0_111 "},"多线程.html":{"url":"多线程.html","title":"多线程","keywords":"","body":"多线程 目录 HelloWorld 线程状态 获得线程状态 线程优先级 守护线程 睡眠 中断 Thread 方法 init start currentThread 参考文章 HelloWorld 在 Java 中有两种方式创建线程，第一种方式是实现 Runnable 接口，第二种方式是继承 Thread 类，下面是使用示例： public class RunnableDemo implements Runnable{ @Override public void run() { System.out.println(\"I am in runnable Demo\"); } public static void main(String[] args) { Thread thread = new Thread(new RunnableDemo()); thread.start(); } } public class ThreadDemo extends Thread{ @Override public void run() { System.out.println(\"I am in Thread Demo\"); } public static void main(String[] args) { Thread thread = new ThreadDemo(); thread.start(); } } 如果启动线程，需要调用 start 方法，直接运行 run 不会启动新的线程。 线程状态 在线程执行期间，会经历多种状态，下面是一个示意图： 图片来自 Java 并发编程的艺术 下面是线程生命周期对应的几种状态 New - 初始状态，线程刚被创建，但是还没有调用 start 方法 Runnable(Ready to run) - 可运行状态，其他线程调用了该线程的 start 方法。该状态的位于可运行的线程池中，等待被线程调度选中，获得 CPU 的使用权。 Running - 运行状态，Runnable 线程获得了 CPU 使用权，执行程序代码。 Blocked - 阻塞状态，表示线程被锁阻塞。例如进入 synchronized 同步块时等待锁。 Waiting - 等待状态，处于该状态的线程一个是调用了下面3个方法：Object.wait, Thread.join 或者 LockSupport.park。处于 Waiting 状态的线程需要等待其他线程做出一些特定行为，例如通过调用 Object.wait() 等待的线程需要另外一个线程执行 Object.notify() 或者 Object.notifyAll() 来唤醒。 Time Waiting - 超时等待，当等待时间超过指定时间后会自行返回。 Terminated - 终止状态，表示线程已经执行完毕 在 JDK 中定义了线程的六种状态，位于 Thread.State 中，下面是 State 的定义： public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * * {@link Object#wait() Object.wait} with no timeout * {@link #join() Thread.join} with no timeout * {@link LockSupport#park() LockSupport.park} * * * A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called Object.wait() * on an object is waiting for another thread to call * Object.notify() or Object.notifyAll() on * that object. A thread that has called Thread.join() * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * * {@link #sleep Thread.sleep} * {@link Object#wait(long) Object.wait} with timeout * {@link #join(long) Thread.join} with timeout * {@link LockSupport#parkNanos LockSupport.parkNanos} * {@link LockSupport#parkUntil LockSupport.parkUntil} * */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 获得线程状态 Thread 类提供了 getState 方法来获得线程状态，下面是一个使用示例： public class StateDemo extends Thread { @Override public void run() { System.out.printf(\"%-18s %s\\n\",\"in run method:\", getState()); } public static void main(String[] args) throws InterruptedException { Thread thread = new StateDemo(); System.out.printf(\"%-18s %s\\n\",\"init:\", thread.getState()); thread.run(); System.out.printf(\"%-18s %s\\n\", \"after run:\", thread.getState()); thread.start(); System.out.printf(\"%-18s %s\\n\",\"after start:\", thread.getState()); Thread.sleep(1); System.out.printf(\"%-18s %s\\n\",\"finish:\", thread.getState()); } } 线程优先级 在 Java 标准中，可以通过设置优先级来调整线程获得时间片的优先程度。Java 中定义的线程优先级的范围是1~10，默认优先级是 5，下面是 Thread 类中关于几个变量的定义： /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 通过 setPriority 方法可以设置线程的优先级。原则上优先级高的线程会优先获得执行时间，但是并不能保证一定会这样，而且在不同的 JVM 以及操作系统中，对线程优先级的划分和优先级的支持程度是不一样，有些操作系统有可能会忽略优先级的设定。下面是一个使用线程优先级的示例： public class PriorityDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 输出结果为： Thread-0(1), loop 0 Thread-0(1), loop 1 Thread-0(1), loop 2 Thread-0(1), loop 3 Thread-0(1), loop 4 Thread-0(1), loop 5 Thread-0(1), loop 6 Thread-0(1), loop 7 Thread-0(1), loop 8 Thread-0(1), loop 9 Thread-1(10), loop 0 Thread-1(10), loop 1 Thread-1(10), loop 2 Thread-1(10), loop 3 Thread-1(10), loop 4 Thread-1(10), loop 5 Thread-1(10), loop 6 Thread-1(10), loop 7 Thread-1(10), loop 8 Thread-1(10), loop 9 从结果可以看到，优先级并没有起到什么作用。所以程序的正确性不能依赖线程的优先级高低。 守护线程 守护 （Daemon） 线程是一种支持型线程，主要用作后天的调度以及支持性工作。虚拟机的垃圾回收线程就是守护线程。当 Java 虚拟机中不存在非守护线程时，Java 虚拟机就会退出。通过 setDaemon 方法设置守护线程。需要注意的一点是当 Java 虚拟机退出守护线程时，finally 块并不一定会执行。下面是一个使用示例： public class DaemonDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try{ TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"run finally in daemon thread.\"); } } }); thread.setDaemon(true); thread.start(); } } 运行上面的程序，不会输出 run finally in daemon thread.，因为主线程结束时，TimeUnit.SECONDS.sleep(1); 还没执行完。所以不要用守护线程来完成资源回收的工作。关于守护线程具体有什么应用，可以参考下面的回答：http://stackoverflow.com/questions/7067578/when-are-daemon-threads-useful 睡眠 Thread 中 sleep 方法会使线程进入睡眠状态，从而让出 CPU 时间，供其它线程使用。sleep 是一个静态方法，只会使当前线程进入睡眠状态。同时线程在睡眠时不会让出拥有的对象锁。它的主要作用就是为了不让当前线程霸占进程所获取的 CPU 资源，给其他的线程留出执行的时间。sleep方法有两个重载的形式，一种是结果一个毫秒时间 （ millisecond），一个是接受一个毫秒 + 纳秒时间（nanosecond），如下所示： public static native void sleep(long millis) throws InterruptedException; public static void sleep(long millis, int nanos) throws InterruptedException { if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } sleep(millis); } 从上面的代码中我们可以看到，对于 sleep(long millis, int nanos) 方法，线程最终还是按照毫秒睡眠的，只是超过纳秒时间超过 0.5 毫秒，将睡眠的毫秒时间加 1。看上去这个方面并没有作用，那么为什么还要定义这个方法呢，具体的可以参考这里 What's the purpose of sleep(long millis, int nanos)?，大体意思就是，有些系统支持纳秒级睡眠的操作，并且纳秒级睡眠对该系统比较重要。但是有些系统比如 Windows 并不支持纳秒级睡眠，所以为了兼容不同的系统，就定义了该方法，对于不支持纳秒睡眠的系统，用毫秒来代替。还要注意的一点就是这里传入的睡眠时间是线程的最少的睡眠时间，到达了指定的睡眠时间后，线程有可能无法获得 CPU 时间，因此就无法立即执行。如果对睡眠的线程调用 interrupt 方法，会使线程抛出 InterruptedException 异常而终止睡眠状态。下面是一个示例： public class SleepDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try { for(int i = 0; i 中断 Java 中的中断机制是一种协作机制，通过中断并不能直接终止另外一个线程，而需要被中断的线程自己处理中断。运行面的代码，程序会一直执行下去，即便在主线程里对 demo 线程执行了中断操作，demo 线程还是会继续执行。下面的代码中 demo.interrupt() 操作只是将 demo 线程的中断状态设为 true，并没有实质性的操作。 public class InterruptDemo { public static void main(String[] args) throws InterruptedException { Thread demo = new Thread(new Runnable() { @Override public void run() { int threshold = 10000; int index = 1; while (true) { if(index++ % threshold == 0) { System.out.println(index); index = 1; } } } }); demo.start(); TimeUnit.SECONDS.sleep(1); demo.interrupt(); } } 每个线程中都有一个与中断相关联的 boolean 属性，用来表示线程的中断状态（interrupt status）。中断状态初始时为 false。当另外一个线程通过调用 interrupt 方法中断一个线程时，会出现以下两种情况： 如果被中断线程正在执行一个低级可中断的阻塞方法，例如 Thread.sleep()、Thread.join() 或者 Object.wait()，那么它将取消阻塞并且抛出 InterruptedException 如果线程没有执行上面的方法，那么 interrupt 只是将该线程的中断状态设置为 true。在被中断的线程里可以通过轮询中断状态，查看它是否被请求正在停止做的事。 中断状态可以通过 Thread.isInterrupted() 方法来读取，该方法只会 Thread 方法 在 Thread 类中定义了一些其他的方法，下面介绍一下这些方法。 init 在运行线程之前首先构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，例如线程所属的线程组、线程优先级等信息。Thread 类通过一个私有的 init 方法，用来初始化线程，下面是代码： /** * Initializes a Thread. * * @param g the Thread group * @param target the object whose run() method gets called * @param name the name of the new Thread * @param stackSize the desired stack size for the new thread, or * zero to indicate that this parameter is to be ignored. * @param acc the AccessControlContext to inherit, or * AccessController.getContext() if null */ private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name.toCharArray(); // 当前正在运行的线程是新线程的父线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 在上面的过程中，一个新构造的线程对象是由其 Parent 线程来进行空间分配的，而 Child 线程继承了父线程是否为 Daemon、优先级和加载资源的 contextClassLoader以及可继承的 ThreadLocal，同时还会分配一个唯一的线程 ID （nextThreadID 方法，是一个 synchronized 方法）来标识这个Child 线程 start 通过调用 start 方法来启动一个线程，需要注意的是直接运行 run 方法是不会启动新的线程的。下面是 start 的代码，我们看到 start 方法其实是调用了一个 native 方法来启动线程的。 public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); currentThread 通过 currentThread 方法可以获得当前正在运行的线程，下面是获得主线程信息的一个例子： public class CurrentThreadDemo { public static void main(String[] args) { Thread thread = Thread.currentThread(); System.out.println(thread.getId() + \" \" + thread.getName()); } } 参考文章 Java 并发编程的艺术 Java 理论与实践: 处理 InterruptedException 详细分析Java中断机制 Java - Multithreading Multithreading in java with examples "}}