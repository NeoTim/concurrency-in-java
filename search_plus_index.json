{"./":{"url":"./","title":"前言","keywords":"","body":"Java 并发编程学习笔记 参考资料: Java 并发编程实战 Java 并发编程的艺术 Java并发性和多线程 The Java™ Tutorials 说明 使用的 JDK 版本为 1.8.0_111 "},"并发基础.html":{"url":"并发基础.html","title":"并发编程基础","keywords":"","body":"并发编程基础 线程 ThreadLocal "},"线程.html":{"url":"线程.html","title":"线程","keywords":"","body":"线程 目录 HelloWorld 线程状态 获得线程状态 线程优先级 守护线程 睡眠 中断 处理中断 使用场景 Wait and Notify 生产者消费者模式 Thread 方法 init start join yield currentThread 参考文章 HelloWorld 在 Java 中有两种方式创建线程，第一种方式是实现 Runnable 接口，第二种方式是继承 Thread 类，下面是使用示例： public class RunnableDemo implements Runnable{ @Override public void run() { System.out.println(\"I am in runnable Demo\"); } public static void main(String[] args) { Thread thread = new Thread(new RunnableDemo()); thread.start(); } } public class ThreadDemo extends Thread{ @Override public void run() { System.out.println(\"I am in Thread Demo\"); } public static void main(String[] args) { Thread thread = new ThreadDemo(); thread.start(); } } 如果启动线程，需要调用 start 方法，直接运行 run 不会启动新的线程。 线程状态 在线程执行期间，会经历多种状态，下面是一个示意图： 图片来自 Java 并发编程的艺术 下面是线程生命周期对应的几种状态 New - 初始状态，线程刚被创建，但是还没有调用 start 方法 Runnable(Ready to run) - 可运行状态，其他线程调用了该线程的 start 方法。该状态的位于可运行的线程池中，等待被线程调度选中，获得 CPU 的使用权。 Running - 运行状态，Runnable 线程获得了 CPU 使用权，执行程序代码。 Blocked - 阻塞状态，表示线程被锁阻塞。例如进入 synchronized 同步块时等待锁。 Waiting - 等待状态，处于该状态的线程一个是调用了下面3个方法：Object.wait, Thread.join 或者 LockSupport.park。处于 Waiting 状态的线程需要等待其他线程做出一些特定行为，例如通过调用 Object.wait() 等待的线程需要另外一个线程执行 Object.notify() 或者 Object.notifyAll() 来唤醒。 Time Waiting - 超时等待，当等待时间超过指定时间后会自行返回。 Terminated - 终止状态，表示线程已经执行完毕 在 JDK 中定义了线程的六种状态，位于 Thread.State 中，下面是 State 的定义： public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * * {@link Object#wait() Object.wait} with no timeout * {@link #join() Thread.join} with no timeout * {@link LockSupport#park() LockSupport.park} * * * A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called Object.wait() * on an object is waiting for another thread to call * Object.notify() or Object.notifyAll() on * that object. A thread that has called Thread.join() * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * * {@link #sleep Thread.sleep} * {@link Object#wait(long) Object.wait} with timeout * {@link #join(long) Thread.join} with timeout * {@link LockSupport#parkNanos LockSupport.parkNanos} * {@link LockSupport#parkUntil LockSupport.parkUntil} * */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 获得线程状态 Thread 类提供了 getState 方法来获得线程状态，下面是一个使用示例： public class StateDemo extends Thread { @Override public void run() { System.out.printf(\"%-18s %s\\n\",\"in run method:\", getState()); } public static void main(String[] args) throws InterruptedException { Thread thread = new StateDemo(); System.out.printf(\"%-18s %s\\n\",\"init:\", thread.getState()); thread.run(); System.out.printf(\"%-18s %s\\n\", \"after run:\", thread.getState()); thread.start(); System.out.printf(\"%-18s %s\\n\",\"after start:\", thread.getState()); Thread.sleep(1); System.out.printf(\"%-18s %s\\n\",\"finish:\", thread.getState()); } } 线程优先级 在 Java 标准中，可以通过设置优先级来调整线程获得时间片的优先程度。Java 中定义的线程优先级的范围是1~10，默认优先级是 5，下面是 Thread 类中关于几个变量的定义： /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 通过 setPriority 方法可以设置线程的优先级。原则上优先级高的线程会优先获得执行时间，但是并不能保证一定会这样，而且在不同的 JVM 以及操作系统中，对线程优先级的划分和优先级的支持程度是不一样，有些操作系统有可能会忽略优先级的设定。下面是一个使用线程优先级的示例： public class PriorityDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i 输出结果为： Thread-0(1), loop 0 Thread-0(1), loop 1 Thread-0(1), loop 2 Thread-0(1), loop 3 Thread-0(1), loop 4 Thread-0(1), loop 5 Thread-0(1), loop 6 Thread-0(1), loop 7 Thread-0(1), loop 8 Thread-0(1), loop 9 Thread-1(10), loop 0 Thread-1(10), loop 1 Thread-1(10), loop 2 Thread-1(10), loop 3 Thread-1(10), loop 4 Thread-1(10), loop 5 Thread-1(10), loop 6 Thread-1(10), loop 7 Thread-1(10), loop 8 Thread-1(10), loop 9 从结果可以看到，优先级并没有起到什么作用。所以程序的正确性不能依赖线程的优先级高低。 守护线程 守护 （Daemon） 线程是一种支持型线程，主要用作后天的调度以及支持性工作。虚拟机的垃圾回收线程就是守护线程。当 Java 虚拟机中不存在非守护线程时，Java 虚拟机就会退出。通过 setDaemon 方法设置守护线程。需要注意的一点是当 Java 虚拟机退出守护线程时，finally 块并不一定会执行。下面是一个使用示例： public class DaemonDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try{ TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"run finally in daemon thread.\"); } } }); thread.setDaemon(true); thread.start(); } } 运行上面的程序，不会输出 run finally in daemon thread.，因为主线程结束时，TimeUnit.SECONDS.sleep(1); 还没执行完。所以不要用守护线程来完成资源回收的工作。关于守护线程具体有什么应用，可以参考下面的回答：http://stackoverflow.com/questions/7067578/when-are-daemon-threads-useful 睡眠 Thread 中 sleep 方法会使线程进入睡眠状态，从而让出 CPU 时间，供其它线程使用。sleep 是一个静态方法，只会使当前线程进入睡眠状态。同时线程在睡眠时不会让出拥有的对象锁。它的主要作用就是为了不让当前线程霸占进程所获取的 CPU 资源，给其他的线程留出执行的时间。sleep方法有两个重载的形式，一种是结果一个毫秒时间 （ millisecond），一个是接受一个毫秒 + 纳秒时间（nanosecond），如下所示： public static native void sleep(long millis) throws InterruptedException; public static void sleep(long millis, int nanos) throws InterruptedException { if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } sleep(millis); } 从上面的代码中我们可以看到，对于 sleep(long millis, int nanos) 方法，线程最终还是按照毫秒睡眠的，只是超过纳秒时间超过 0.5 毫秒，将睡眠的毫秒时间加 1。看上去这个方面并没有作用，那么为什么还要定义这个方法呢，具体的可以参考这里 What's the purpose of sleep(long millis, int nanos)?，大体意思就是，有些系统支持纳秒级睡眠的操作，并且纳秒级睡眠对该系统比较重要。但是有些系统比如 Windows 并不支持纳秒级睡眠，所以为了兼容不同的系统，就定义了该方法，对于不支持纳秒睡眠的系统，用毫秒来代替。还要注意的一点就是这里传入的睡眠时间是线程的最少的睡眠时间，到达了指定的睡眠时间后，线程有可能无法获得 CPU 时间，因此就无法立即执行。如果对睡眠的线程调用 interrupt 方法，会使线程抛出 InterruptedException 异常而终止睡眠状态。下面是一个示例： public class SleepDemo { public static void main(String[] args) { Thread thread = new Thread(new Runnable() { @Override public void run() { try { for(int i = 0; i 中断 Java 中的中断机制是一种协作机制，通过中断并不能直接终止另外一个线程，而需要被中断的线程自己处理中断。运行面的代码，程序会一直执行下去，即便在主线程里对 demo 线程执行了中断操作，demo 线程还是会继续执行。下面的代码中 demo.interrupt() 操作只是将 demo 线程的中断状态设为 true，并没有实质性的操作。 public class InterruptDemo { public static void main(String[] args) throws InterruptedException { Thread demo = new Thread(new Runnable() { @Override public void run() { int threshold = 10000; int index = 1; while (true) { if(index++ % threshold == 0) { System.out.println(index); index = 1; } } } }); demo.start(); TimeUnit.SECONDS.sleep(1); demo.interrupt(); } } 每个线程中都有一个与中断相关联的 boolean 属性，用来表示线程的中断状态（interrupt status）。中断状态初始时为 false。当另外一个线程通过调用 interrupt 方法中断一个线程时，会出现以下两种情况： 如果被中断线程正在执行一个低级可中断的阻塞方法，例如 Thread.sleep()、Thread.join() 或者 Object.wait()，那么它将取消阻塞并且抛出 InterruptedException 如果线程没有执行上面的方法，那么 interrupt 只是将该线程的中断状态设置为 true。在被中断的线程里可以通过轮询中断状态，查看它是否被请求正在停止做的事。 中断状态可以通过 isInterrupted() 方法来读取，该方法只会读取中断状态。还有一个静态方法 -- Thread.interrupted()，该方法会首先读取中断状态，然后清除当前的中断状态（中断状态重设为 false）。下面是两种方法的源码： /** * Tests whether the current thread has been interrupted. The * interrupted status of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return true if the current thread has been interrupted; * false otherwise. * @see #isInterrupted() * @revised 6.0 */ public static boolean interrupted() { return currentThread().isInterrupted(true); } /** * Tests whether this thread has been interrupted. The interrupted * status of the thread is unaffected by this method. * * A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return true if this thread has been interrupted; * false otherwise. * @see #interrupted() * @revised 6.0 */ public boolean isInterrupted() { return isInterrupted(false); } /** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */ private native boolean isInterrupted(boolean ClearInterrupted); 处理中断 在前面提到，对于低级的阻塞方法，如果线程被设置中断，会跑出 InterruptedException，当线程抛出 InterruptedException 之后，线程的中断状态会被重置为 false，下面是一个示例： public void testInterruptException() throws InterruptedException { Thread thread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(4000); } catch (InterruptedException e) { System.out.println(\"Thread is interrupted, and current stage is: \" + Thread.currentThread().isInterrupted()); } } }); thread.start(); Thread.sleep(1000); thread.interrupt(); } 输出结果如下： Thread is interrupted, and current stage is: false 对于会抛出 InterruptedException 的阻塞方法，可以使用下面几种策略处理： 将异常抛给上层调用方法 public void method() throws InterruptedException {} 在将异常抛出之前做一些清理工作 public void method() throws InterruptedException{ try{ value = 10; } catch(InterruptedException e) { value = 0; throw e; } } 在本层方法处理使用该方式需要注意的不要 生吞中断。在上面我们提到抛出 InterruptedException 异常之后，线程中断状态会被设置为 false，如果不做处理，那么这样上层的调用方法就无法准确的获得当前线程的中断状态（不管当前线程是否被中断，上层方法获得的线程状态总是 false，就类似于中断被下层方法“吞”了）。所以，我们在捕捉了异常之后，应该重新调用 interrupt() 设置中断状态： public static void handleInterruptException() { Thread thread = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(4000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); //e.printStackTrace(); } } }); thread.start(); thread.interrupt(); } 对于一般的方法，我们可以使用轮询的方式来查看当前线程的中断状态，根据中断状态做出相应的处理： public static void handleInterruptByHand() throws InterruptedException { Thread thread = new Thread(new Runnable() { @Override public void run() { int max = 10000000, index = 0; while (!Thread.currentThread().isInterrupted()) { index++; if (index > max) { index = 0; System.out.println(\"doing task......\"); } } System.out.println(\"finish task\"); } }); thread.start(); Thread.sleep(100); thread.interrupt(); } 使用场景 中断的使用场景大概有以下几个： 点击某个桌面应用中的取消按钮时； 某个操作超过了一定的执行时间限制需要中止时； 多个线程做相同的事情，只要一个线程成功其它线程都可以取消时； 一组线程中的一个或多个出现错误导致整组都无法继续时； 当一个应用或服务需要停止时。 Wait and Notify 在 Java 中可以用 wait/notify 来实现进程间的通信，一个经典的例子就是生产者和消费者模型。与 wait/notify 相关的函数有下面5个，这 5 个函数都是 Object 类中的方法，所以线程 wait 或者 notify 时都会关联一个相关的对象。 public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException { if (timeout 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos > 0) { timeout++; } wait(timeout); } public final void wait() throws InterruptedException { wait(0); } public final native void notify(); public final native void notifyAll(); 首先来说一下上述函数的功能： wait() - 使线程处于针对于当前对象的等待状态。通过另外一个线程调用等待对象的 notify() 或者 notifyAll() 方法可以唤醒等待的线程。wait 方法会抛出 InterruptedException，也就是说如果对等待线程调用 interrupt() 方法，也会使线程退出等待状态。在线程调用某个对象的 wait 方法之前，需要首先获得该对象的锁。当线程处于等待时会释放掉该对象的锁。当等待线程被唤醒之后需要重新获得等待对象的锁。处于等待状态的线程不会再占用 CPU 资源。 wait(long) / wait(long, int) - 超时等待，当超过预设的的时间之后即使没有 notify 或者 interrupt，线程也会退出等待状态。 notify() - 唤醒一个针对当前对象等待的线程，如果有多个线程正在等待当前对象，会随机选择一个唤醒。 notigyAll() - 唤醒所有针对当前对象等待的线程。 为什么线程在调用对象的 wait 或者 notify 方法之前需要首先获得对象锁呢？个人觉得主要原因就是为了确保某一个时间内只有一个线程执行该对象的 wait 或者 notify 方法。假设线程 1 正在执行 a.wait() ，随后线程 2 执行 a.notify()（线程 1 还没完成等待工作），线程 1 和 2 都没有获得对象锁，那么问题来了，因为线程 1 还没有完成等待的操作，那么线程 2 也就不知道线程 1 在等待，也就不会唤醒线程 1，当线程 1 完成等待操作之后，线程 2 也早已完成唤醒操作，线程 1 就会一直处于等待状态。 在 Java 中每个对象都有一个内置的锁，被称为 intrinsic lock 或者 monitor lock，Java 的 API 文档中经常把这个内置锁简称为 monitor。这里将其称为对象锁。获得对象锁的途径有下面三种（直接从 Javadoc 中抄的）： By executing a synchronized instance method of that object. By executing the body of a {@code synchronized} statement that synchronizes on the object. For objects of type {@code Class,} by executing a synchronized static method of that class. 也就是下面三种方式： // 该方法获得是当前对象的锁 public synchronized void method(){} // 该方法获得的是 Class 对象的锁 public synchronized static void staticMethod(){} // 该方法获得是 obj 对象的锁 synchronized (obj) { obj.notify(); } 所以我们看到在使用 wait 或者 notify 方法时，必定要和 synchronized 方法或者 synchronized 同步块相关联，诸如下面的形式： synchronized(obj) { obj.wait(); } public synchronized void method() throws InterruptedException { wait(); } 为了保证程序的正确性，我们也需要对象的修改做同步。如果同步对象修改和 wait/notify 之间有一定的关联，那么需要将这两个操作放到一个同步块中。例如生产者消费者模型中：生产者生产了商品需要唤醒消费者，就需要将生产商品和唤醒消费者的操作放到一个同步块中，如下面的形式。 // buffer 是共享变量 Queue buffer = new LinkedList (); public void method() { synchronized(buffer) { buffer.add(data); notify(); } } 假设对两者分别同步，如下面的代码： class BlockingQueue { Queue buffer = new LinkedList(); public void give(String data) { synchronized (buffer) { buffer.add(data); } synchronized (buffer) { notify(); } } public String take() throws InterruptedException { synchronized (buffer) { while (buffer.isEmpty()) wait(); } synchronized (buffer) { return buffer.remove(); } } } 对于上述代码，下面是有可能发生的情况： 一个消费者线程调用 take() 方法，发现 buffer 为空 在消费者线程调用 wait() 方法之前，生产者线程来了，它调用 give() 方法，生产东西放到了 buffer 里并调用 notify() 方法 此时消费者开始调用 wait() 方法，假设此后生产者线程都不再生产商品，即不在调用 give() 方法了，那么消费者线程将一直等待下去，即便有商品可用。 所以需要将共享变量的修改以及 wait/notify 调用放到同一个同步块中。 同时对于 wait 的条件判断，我们需要使用 while，而不是 if ，如下所示： synchronized(obj) { while (condition) { wait(); } } 这是因为线程可能存在 spurious wakeup，也就是说即便没有 notify , interrupt 或者超时，线程也有可能从 wait 的状态中醒过来。所以需要用 while 循环来判断是否需要线程再次进入 wait 状态。 关于 wait 和 notify 方法为什么会定义在 Object 类里，可以参考 这篇文章。 生产者消费者模式 http://www.infoq.com/cn/articles/producers-and-consumers-mode https://software.intel.com/zh-cn/blogs/2014/02/28/java http://blog.csdn.net/luohuacanyue/article/details/14648185 http://stackoverflow.com/questions/2779484/why-must-wait-always-be-in-synchronized-block http://www.jianshu.com/p/75d154292dcc 下面是生产者消费者的一个简单示例 import java.util.LinkedList; import java.util.Queue; public class ProducerConsumer { public static class Storage { private final int MAX_ITEM = 5; private Queue queue = new LinkedList<>(); public synchronized void put(Integer item) { while (queue.size() >= MAX_ITEM) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } queue.add(item); System.out.println(\"produce product: \" + item); notifyAll(); } public synchronized Integer take() { Integer item = 0; while (queue.isEmpty()) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // slow down the consumer speed. try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } item = queue.poll(); System.out.println(\"consume product: \" + item); notifyAll(); return item; } } public static class ProducerThread implements Runnable { private Storage storage; public ProducerThread(Storage storage) { this.storage = storage; } @Override public void run() { int num = 20; for (int i = 0; i Thread 方法 在 Thread 类中定义了一些其他的方法，下面介绍一下这些方法。 init 在运行线程之前首先构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，例如线程所属的线程组、线程优先级等信息。Thread 类通过一个私有的 init 方法，用来初始化线程，下面是代码： /** * Initializes a Thread. * * @param g the Thread group * @param target the object whose run() method gets called * @param name the name of the new Thread * @param stackSize the desired stack size for the new thread, or * zero to indicate that this parameter is to be ignored. * @param acc the AccessControlContext to inherit, or * AccessController.getContext() if null */ private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name.toCharArray(); // 当前正在运行的线程是新线程的父线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } 在上面的过程中，一个新构造的线程对象是由其 Parent 线程来进行空间分配的，而 Child 线程继承了父线程是否为 Daemon、优先级和加载资源的 contextClassLoader以及可继承的 ThreadLocal，同时还会分配一个唯一的线程 ID （nextThreadID 方法，是一个 synchronized 方法）来标识这个Child 线程 start 通过调用 start 方法来启动一个线程，需要注意的是直接运行 run 方法是不会启动新的线程的。下面是 start 的代码，我们看到 start 方法其实是调用了一个 native 方法来启动线程的。 public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); join 如果线程 T 执行了 thread.join() 语句，那么线程 T 将等待 thread 线程执行完，再往下执行，下面是一个使用示例： public class JoinDemo { public static class JoinThread implements Runnable{ @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"in JoinThread\"); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new JoinThread()); thread.start(); System.out.println(\"in main thread: before thread.join()\"); thread.join(); System.out.println(\"in main thread: after thread.join()\"); } } 下面是 join 方法的实现： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos >= 500000 || (nanos != 0 && millis == 0)) { millis++; } join(millis); } public final void join() throws InterruptedException { join(0); } public final native boolean isAlive(); 我们看到 join 实际上是调用了 wait 方法，wait 获得的对象锁就是 thread 对象，当 thread 执行完之后再唤醒 wait 方法（底层实现的）。 yield yield 是 Thread 类中的一个静态方法。yield 方法会给调度器发送一个暗示 （hint），告诉调度器当前线程将要让出 CPU 资源，让其他同优先级或者高优先级的线程来使用 CPU。使用这个方法有几点需要注意的地方： 调度器可以选择忽略 yield 发出的暗示。 不同的系统以及不同的 Java 版本对于 yield 的实现方法不同，具体的可以参考 这篇文章。在 Windows 的高版本 JDK 中（>=1.6），yield 只是将当前线程从运行状态 （running）变为就绪状态（ready），当前线程还是有可能再次竞争到 CPU 资源，再次执行。在 Linux 的实现中，需要其他线程都获得了 CPU 资源执行（不一定执行完）之后，被 yield 的线程才可以再次获取 CPU 资源。 Java 中的线程优先级也是个不靠谱的东西。 和线程优先级一样，程序的正确性不要依赖于 yield 方法。一般来说，yield 只用于调试。下面是一个示例： public class YieldDemo { public static class YieldThread implements Runnable { @Override public void run() { int num = 10; for (int i = 0; i currentThread 通过 currentThread 方法可以获得当前正在运行的线程，下面是获得主线程信息的一个例子： public class CurrentThreadDemo { public static void main(String[] args) { Thread thread = Thread.currentThread(); System.out.println(thread.getId() + \" \" + thread.getName()); } } 参考文章 Java 并发编程的艺术 Java 理论与实践: 处理 InterruptedException 详细分析Java中断机制 Concurrent Programming in Java 如何在 Java 中正确使用 wait, notify 和 notifyAll The Java™ Tutorials -- Concurrency Java - Multithreading Multithreading in java with examples "},"ThreadLocal.html":{"url":"ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 线程局部变量 使用示例 具体实现 ThreadLocalMap 散列表 实现 副本变量存取 ThreadLocal 散列值 应用场景 参考文章 线程局部变量 在多线程环境下，之所以会有并发问题，就是因为不同的线程会同时访问同一个共享变量，例如下面的形式 public class MultiThreadDemo { public static class Number { private int value = 0; public void increase() throws InterruptedException { value = 10; Thread.sleep(10); System.out.println(\"increase value: \" + value); } public void decrease() throws InterruptedException { value = -10; Thread.sleep(10); System.out.println(\"decrease value: \" + value); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread decreaseThread = new Thread(new Runnable() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }); increaseThread.start(); decreaseThread.start(); } } 在上面的代码中，increase 线程和 decrease 线程会操作同一个 number 中 value，那么输出的结果是不可预测的，因为当前线程修改变量之后但是还没输出的时候，变量有可能被另外一个线程修改，下面是一种可能的情况： increase value: 10 decrease value: 10 一种解决方法是在 increase() 和 decrease() 方法上加上 synchronized 关键字进行同步，这种做法其实是将 value 的 赋值 和 打印 包装成了一个原子操作，也就是说两者要么同时进行，要不都不进行，中间不会有额外的操作。我们换个角度考虑问题，如果 value 只属于 increase 线程或者 decrease 线程，而不是被两个线程共享，那么也不会出现竞争问题。一种比较常见的形式就是局部（local）变量（这里排除局部变量引用指向共享对象的情况），如下所示： public void increase() throws InterruptedException { int value = 10; Thread.sleep(10); System.out.println(\"increase value: \" + value); } 不论 value 值如何改变，都不会影响到其他线程，因为在每次调用 increase 方法时，都会创建一个 value 变量，该变量只对当前调用 increase 方法的线程可见。借助于这种思想，我们可以对每个线程创建一个共享变量的副本，该副本只对当前线程可见（可以认为是线程私有的变量），那么修改该副本变量时就不会影响到其他的线程。一个简单的思路是使用 Map 存储每个变量的副本，将当前线程的 id 作为 key，副本变量作为 value 值，下面是一个实现： public class SimpleImpl { public static class CustomThreadLocal { private Map cacheMap = new HashMap<>(); private int defaultValue ; public CustomThreadLocal(int value) { defaultValue = value; } public Integer get() { long id = Thread.currentThread().getId(); if (cacheMap.containsKey(id)) { return cacheMap.get(id); } return defaultValue; } public void set(int value) { long id = Thread.currentThread().getId(); cacheMap.put(id, value); } } public static class Number { private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException { value.set(10); Thread.sleep(10); System.out.println(\"increase value: \" + value.get()); } public void decrease() throws InterruptedException { value.set(-10); Thread.sleep(10); System.out.println(\"decrease value: \" + value.get()); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new Thread(new Runnable() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread decreaseThread = new Thread(new Runnable() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }); increaseThread.start(); decreaseThread.start(); } } 但是上面的实现会存在下面的问题： 每个线程对应的副本变量的生命周期不是由线程决定的，而是由共享变量的生命周期决定的。在上面的例子中，即便线程执行完，只要 number 变量存在，线程的副本变量依然会存在（存放在 number 的 cacheMap 中）。但是作为特定线程的副本变量，该变量的生命周期应该由线程决定，线程消亡之后，该变量也应该被回收。 多个线程有可能会同时操作 cacheMap，需要对 cacheMap 进行同步处理。 为了解决上面的问题，我们换种思路，每个线程创建一个 Map，存放当前线程中副本变量，用 CustomThreadLocal 的实例作为 key 值，下面是一个示例： public class SimpleImpl2 { public static class CommonThread extends Thread { Map cacheMap = new HashMap<>(); } public static class CustomThreadLocal { private int defaultValue; public CustomThreadLocal(int value) { defaultValue = value; } public Integer get() { Integer id = this.hashCode(); Map cacheMap = getMap(); if (cacheMap.containsKey(id)) { return cacheMap.get(id); } return defaultValue; } public void set(int value) { Integer id = this.hashCode(); Map cacheMap = getMap(); cacheMap.put(id, value); } public Map getMap() { CommonThread thread = (CommonThread) Thread.currentThread(); return thread.cacheMap; } } public static class Number { private CustomThreadLocal value = new CustomThreadLocal(0); public void increase() throws InterruptedException { value.set(10); Thread.sleep(10); System.out.println(\"increase value: \" + value.get()); } public void decrease() throws InterruptedException { value.set(-10); Thread.sleep(10); System.out.println(\"decrease value: \" + value.get()); } } public static void main(String[] args) throws InterruptedException { final Number number = new Number(); Thread increaseThread = new CommonThread() { @Override public void run() { try { number.increase(); } catch (InterruptedException e) { e.printStackTrace(); } } }; Thread decreaseThread = new CommonThread() { @Override public void run() { try { number.decrease(); } catch (InterruptedException e) { e.printStackTrace(); } } }; increaseThread.start(); decreaseThread.start(); } } 在上面的实现中，当线程消亡之后，线程中 cacheMap 也会被回收，它当中存放的副本变量也会被全部回收，并且 cacheMap 是线程私有的，不会出现多个线程同时访问一个 cacheMap 的情况。在 Java 中，ThreadLocal 类的实现就是采用的这种思想，注意只是思想，实际的实现和上面的并不一样。 使用示例 Java 使用 ThreadLocal 类来实现线程局部变量模式，ThreadLocal 使用 set 和 get 方法设置和获取变量，下面是函数原型： public void set(T value); public T get(); 下面是使用 ThreadLocal 的一个完整示例： public class ThreadLocalDemo { private static ThreadLocal threadLocal = new ThreadLocal<>(); private static int value = 0; public static class ThreadLocalThread implements Runnable { @Override public void run() { threadLocal.set((int)(Math.random() * 100)); value = (int) (Math.random() * 100); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.printf(Thread.currentThread().getName() + \": threadLocal=%d, value=%d\\n\", threadLocal.get(), value); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new ThreadLocalThread()); Thread thread2 = new Thread(new ThreadLocalThread()); thread.start(); thread2.start(); thread.join(); thread2.join(); } } 下面是一种可能的输出： Thread-0: threadLocal=87, value=15 Thread-1: threadLocal=69, value=15 我们看到虽然 threadLocal 是静态变量，但是每个线程都有自己的值，不会受到其他线程的影响。 具体实现 ThreadLocal 的实现思想，我们在前面已经说了，每个线程维护一个 ThreadLocalMap 的映射表，映射表的 key 是 ThreadLocal 实例本身，value 是要存储的副本变量。ThreadLocal 实例本身并不存储值，它只是提供一个在当前线程中找到副本值的 key。 如下图所示： 图片来自 http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/ 我们从下面三个方面看下 ThreadLocal 的实现： 存储线程副本变量的数据结构 如何存取线程副本变量 如何对 ThreadLocal 的实例进行 Hash ThreadLocalMap 线程使用 ThreadLocalMap 来存储每个线程副本变量，它是 ThreadLocal 里的一个静态内部类。ThreadLocalMap 也是采用的散列表（Hash）思想来实现的，但是实现方式和 HashMap 不太一样。我们首先看下散列表的相关知识： 散列表 理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。下面是理想散列表的一个示意图： 图片来自 数据结构与算法分析: C语法描述 在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式： 分离链表法（separate chaining） 开放定址法（open addressing） 分离链表法分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素。下面是一个示意图： 图片来自 http://faculty.cs.niu.edu/~freedman/340/340notes/340hash.htm 开放定址法开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 -- 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示： 图片来自 http://alexyyek.github.io/2014/12/14/hashCollapse/ 关于两种方式的比较，可以参考 这篇文章。ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。 实现 我们知道 Map 是一种 key-value 形式的数据结构，所以在散列数组中存储的元素也是 key-value 的形式。ThreadLocalMap 使用 Entry 类来存储数据，下面是该类的定义： static class Entry extends WeakReference > { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) { super(k); value = v; } } Entry 将 ThreadLocal 实例作为 key，副本变量作为 value 存储起来。注意 Entry 中对于 ThreadLocal 实例的引用是一个弱引用，该引用定义在 Reference 类（WeakReference的父类）中，下面是 super(k) 最终调用的代码： Reference(T referent) { this(referent, null); } Reference(T referent, ReferenceQueue queue) { this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue; } 关于弱引用和为什么使用弱引用可以参考 Java 理论与实践: 用弱引用堵住内存泄漏 和 深入分析 ThreadLocal 内存泄漏问题。下面看一下 ThreadLocalMap 的 set 函数 private void set(ThreadLocal key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置 int i = key.threadLocalHashCode & (len - 1); // 使用线性探测法查找元素 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); // ThreadLocal 对应的 key 存在，直接覆盖之前的值 if (k == key) { e.value = value; return; } // key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前数组中的 Entry 是一个陈旧（stale）的元素 if (k == null) { // 用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏，具体可以看源代码，没看太懂 replaceStaleEntry(key, value, i); return; } } // ThreadLocal 对应的 key 不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的 Entry。 tab[i] = new Entry(key, value); int sz = ++size; // cleanSomeSlot 清理陈旧的 Entry（key == null），具体的参考源码。如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash。 if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } 关于 set 方法，有几点需要地方： int i = key.threadLocalHashCode & (len - 1);，这里实际上是对 len-1 进行了取余操作。之所以能这样取余是因为 len 的值比较特殊，是 2 的 n 次方，减 1 之后低位变为全 1，高位变为全 0。例如 16，减 1 之后对应的二进制为: 00001111，这样其他数字中大于 16 的部分就会被 0 与掉，小于 16 的部分就会保留下来，就相当于取余了。 在 replaceStaleEntry 和 cleanSomeSlots 方法中都会清理一些陈旧的 Entry，防止内存泄漏 threshold 的值大小为 threshold = len * 2 / 3; rehash 方法中首先会清理陈旧的 Entry，如果清理完之后元素数量仍然大于 threshold 的 3/4，则进行扩容操作（数组大小变为原来的 2倍）private void rehash() { expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size >= threshold - threshold / 4) resize(); } 我们再看一下 getEntry （没有 get 方法，就叫 getEntry）方法： private Entry getEntry(ThreadLocal key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } 因为 ThreadLocalMap 中采用开放定址法，所以当前 key 的散列值和元素在数组中的索引并不一定完全对应。所以在 get 的时候，首先会看 key 的散列值对应的数组元素是否为要查找的元素，如果不是，再调用 getEntryAfterMiss 方法查找后面的元素。 private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } 最后看一下删除操作。删除其实就是将 Entry 的键值设为 null，变为陈旧的 Entry。然后调用 expungeStaleEntry 清理陈旧的 Entry。 private void remove(ThreadLocal key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len - 1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } 副本变量存取 前面说完了 ThreadLocalMap，副本变量的存取操作就很好理解了。下面是 ThreadLocal 中的 set 和 get 方法的实现： public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T) e.value; return result; } } return setInitialValue(); } 存取的基本流程就是首先获得当前线程的 ThreadLocalMap，将 ThreadLocal 实例作为键值传入 Map，然后就是进行相关的变量存取工作了。线程中的 ThreadLocalMap 是懒加载的，只有真正的要存变量时才会调用 createMap 创建，下面是 createMap 的实现： void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } 如果想要给 ThreadLocal 的副本变量设置初始值，需要重写 initialValue 方法，如下面的形式： ThreadLocal threadLocal = new ThreadLocal() { protected Integer initialValue() { return 0; } }; ThreadLocal 散列值 当创建了一个 ThreadLocal 的实例后，它的散列值就已经确定了，下面是 ThreadLocal 中的实现： /** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.threadLocals and * inheritableThreadLocals). The ThreadLocal objects act as keys, * searched via threadLocalHashCode. This is a custom hash code * (useful only within ThreadLocalMaps) that eliminates collisions * in the common case where consecutively constructed ThreadLocals * are used by the same threads, while remaining well-behaved in * less common cases. */ private final int threadLocalHashCode = nextHashCode(); /** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); /** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; /** * Returns the next hash code. */ private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } 我们看到 threadLocalHashCode 是一个常量，它通过 nextHashCode() 函数产生。nextHashCode() 函数其实就是在一个 AtomicInteger 变量（初始值为0）的基础上每次累加 0x61c88647，使用 AtomicInteger 为了保证每次的加法是原子操作。而 0x61c88647 这个就比较神奇了，它可以使 hashcode 均匀的分布在大小为 2 的 N 次方的数组里。下面写个程序测试一下: public static void main(String[] args) { AtomicInteger hashCode = new AtomicInteger(); int hash_increment = 0x61c88647; int size = 16; List list = new ArrayList <> (); for (int i = 0; i 我们将 size 设为 16，32 和 64 分别测试一下： // size=16 original:[0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] // size=32 original:[0, 7, 14, 21, 28, 3, 10, 17, 24, 31, 6, 13, 20, 27, 2, 9, 16, 23, 30, 5, 12, 19, 26, 1, 8, 15, 22, 29, 4, 11, 18, 25] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31] // size=64 original:[0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 6, 13, 20, 27, 34, 41, 48, 55, 62, 5, 12, 19, 26, 33, 40, 47, 54, 61, 4, 11, 18, 25, 32, 39, 46, 53, 60, 3, 10, 17, 24, 31, 38, 45, 52, 59, 2, 9, 16, 23, 30, 37, 44, 51, 58, 1, 8, 15, 22, 29, 36, 43, 50, 57] sort: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63] 可以看到随着 size 的变化，hashcode 总能均匀的分布。其实这就是 Fibonacci Hashing，具体可以参考 这篇文章。所以虽然 ThreadLocal 的 hashcode 是固定的，当 ThreadLocalMap 中的散列表调整大小（变为原来的 2 倍）之后重新散列，hashcode 仍能均匀的分布在散列表中。 应用场景 摘自 Java并发编程：深入剖析ThreadLocal 最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。如 private static ThreadLocal connectionHolder = new ThreadLocal () { public Connection initialValue() { return DriverManager.getConnection(DB_URL); } }; public static Connection getConnection() { return connectionHolder.get(); } private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } 参考文章 http://www.iteye.com/topic/103804 http://www.jianshu.com/p/529c03d9b67e http://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java http://jerrypeng.me/2013/06/thread-local-and-magical-0x61c88647/ ThreadLocal是否会引发内存泄露的分析（转） [Java并发包学习七]解密ThreadLocal 数据结构与算法分析: C语法描述 "},"显式锁.html":{"url":"显式锁.html","title":"显式锁","keywords":"","body":"显示锁 公平锁 非公平锁 自旋锁 可重入锁 偏向锁 轻量级锁 重量级锁 轻量级锁 读写锁 互斥锁 锁消除 锁粗化 悲观锁 乐观锁 共享锁 排他锁 "},"Lock框架.html":{"url":"Lock框架.html","title":"Lock 框架","keywords":"","body":"Lock 框架 示例 Lock 框架体系 参考资料 示例 通过使用显式锁，我们可以更加灵活的来处理线程同步。同时使用显式锁可以实现 synchronized 所没有的功能，下面是使用显式锁的一个示例： import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * Created by Jikai Zhang on 2017/4/4. */ public class ReentrantLockTest { private static int count = 1; private static Lock lock = new ReentrantLock(); static class CustomThread implements Runnable { @Override public void run() { lock.lock(); try { count++; Thread.sleep(1000); System.out.println(Thread.currentThread().toString() + \": \" + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } public static void main(String[] args) { Thread thread = new Thread(new CustomThread()); Thread thread2 = new Thread(new CustomThread()); thread.start(); thread2.start(); } } Lock 框架体系 图片来自 https://my.oschina.net/xianggao/blog/88477 参考资料 Java 并发：Lock 框架详解 Java Threads Java Concurrency / Multithreading Tutorial "},"AbstractQueuedSynchronizer.html":{"url":"AbstractQueuedSynchronizer.html","title":"AbstractQueuedSynchronizer","keywords":"","body":"队列同步器 前言 队列同步器 AbstractQueuedSynchronizer（以下简称 AQS），是用来构建锁或者其他同步组件的基础框架。它使用一个 int 成员变量来表示同步状态，通过 CAS 操作对同步状态进行修改，确保状态的改变是安全的。通过内置的 FIFO （First In First Out）队列来完成资源获取线程的排队工作。 CAS 操作 CAS（Compare and Swap），比较并交换，通过利用底层硬件平台的特性，实现原子性操作。CAS 操作涉及到3个操作数，内存值 V，旧的期望值 A，需要修改的新值 B。当且仅当预期值 A 和 内存值 V 相同时，才将内存值 V 修改为 B，否则什么都不做。CAS 操作类似于执行了下面流程 if(oldValue == memory[valueAddress]) { memory[valueAddress] = newValue; } 在上面的流程中，其实涉及到了两个操作，比较以及替换，为了确保程序正确，需要确保这两个操作的原子性（也就是说确保这两个操作同时进行，中间不会有其他线程干扰）。现在的 CPU 中，提供了相关的底层 CAS 指令，即 CPU 底层指令确保了比较和交换两个操作作为一个原子操作进行（其实在这一点上还是有排他锁的. 只是比起用synchronized, 这里的排他时间要短的多.），Java 中的 CAS 函数是借助于底层的 CAS 指令来实现的。更多关于 CPU 底层实现的原理可以参考 这篇文章。我们来看下 Java 中对于 CAS 函数的定义： /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object x); /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); /** * Atomically update Java variable to x if it is currently * holding expected. * @return true if successful */ public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x); 上面三个函数定义在 sun.misc.Unsafe 类中，使用该类可以进行一些底层的操作，例如直接操作原生内存，更多关于 Unsafe 类的文章可以参考 这篇。以 compareAndSwapInt 为例，我们看下如何使用 CAS 函数： import sun.misc.Unsafe; import java.lang.reflect.Field; /** * Created by Jikai Zhang on 2017/4/8. */ public class CASIntTest { private volatile int count = 0; private static final Unsafe unsafe = getUnsafe(); private static final long offset; // 获得 count 属性在 CASIntTest 中的偏移量（内存地址偏移） static { try { offset = unsafe.objectFieldOffset(CASIntTest.class.getDeclaredField(\"count\")); } catch (NoSuchFieldException e) { throw new Error(e); } } // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() { Unsafe unsafe = null; try { Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return unsafe; } public void increment() { int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); } public static void main(String[] args) { CASIntTest casIntTest = new CASIntTest(); casIntTest.increment(); System.out.println(casIntTest.count); } } 在 CASIntTest 类中，我们定义一个 count 变量，其中 increment() 方法是将 count 的值加 1，执行上面的程序，我们会看到输出结果也为 1。下面是将 count 加 1 的代码： int previous = count; unsafe.compareAndSwapInt(this, offset, previous, previous + 1); 在没有线程竞争的条件下，该代码执行的结果是将 count 变量的值加 1（多个线程竞争可能会有线程执行失败），但是在 compareAndSwapInt 函数中，我们并没有传入 count 变量，那么函数是如何修改 count 变量值的呢？其实我们往 compareAndSwapInt 函数中传入了 count 变量在堆内存中的地址，函数直接修改了 count 变量所在内存区域。count 属性在堆内存中的地址是由 CASIntTest 实例的起始内存地址和 count 属性相对于起始内存的偏移量决定的。其中对象属性在对象中的偏移量通过 objectFieldOffset 函数获得，函数原型如下所示。该函数接受一个 Filed 类型的参数，返回该 Filed 属性在对象中的偏移量。 /** * Report the location of a given static field, in conjunction with {@link * #staticFieldBase}. * Do not expect to perform any sort of arithmetic on this offset; * it is just a cookie which is passed to the unsafe heap memory accessors. * * Any given field will always have the same offset, and no two distinct * fields of the same class will ever have the same offset. * * As of 1.4.1, offsets for fields are represented as long values, * although the Sun JVM does not use the most significant 32 bits. * It is hard to imagine a JVM technology which needs more than * a few bits to encode an offset within a non-array object, * However, for consistency with other methods in this class, * this method reports its result as a long value. */ public native long objectFieldOffset(Field f); 下面我们再看一下 compareAndSwapInt 的函数原型。我们知道 CAS 操作需要知道 3 个信息：内存中的值，期望的旧值以及要修改的新值。通过前面的分析，我们知道通过 o 和 offset 我们可以确定属性在内存中的地址，也就是知道了属性在内存中的值。expected 对应期望的旧址，而 x 就是要修改的新值。 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); compareAndSwapInt 函数首先比较一下 expected 是否和内存中的值相同，如果不同证明其他线程修改了属性值，那么就不会执行更新操作，但是程序如果就此返回了，似乎不太符合我们的期望，我们是希望程序可以执行更新操作的，如果其他线程先进行了更新，那么就在更新后的值的基础上进行修改，所以我们一般使用循环配合 CAS 函数，使程序在更新操作完成之后再返回，如下所示： long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) { before = counter; } 下面是使用 CAS 函数实现计数器的一个实例： import sun.misc.Unsafe; import java.lang.reflect.Field; /** * Created by Jikai Zhang on 2017/4/8. */ public class CASCounter { // 通过反射的方式获得 Unsafe 类 public static Unsafe getUnsafe() { Unsafe unsafe = null; try { Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { e.printStackTrace(); } return unsafe; } private volatile long counter = 0; private static final long offset; private static final Unsafe unsafe = getUnsafe(); static { try { offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(\"counter\")); } catch (NoSuchFieldException e) { throw new Error(e); } } public void increment() { long before = counter; while (!unsafe.compareAndSwapLong(this, offset, before, before + 1)) { before = counter; } } public long getCounter() { return counter; } private static long intCounter = 0; public static void main(String[] args) throws InterruptedException { int threadCount = 10; Thread threads[] = new Thread[threadCount]; final CASCounter casCounter = new CASCounter(); for (int i = 0; i 同步队列 同步器依赖内部的同步队列（一个 FIFO）的双向队列来完成同步状态的管理 参考文章 Java 并发编程的艺术 Java Magic. Part 4: sun.misc.Unsafe Java里的CompareAndSet(CAS) "}}