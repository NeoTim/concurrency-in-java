# 线程池
<!-- toc -->

## 前言
线程池是并发中一项常用的优化方法，通过将线程保存起来，减少线程的创建，降低资源消耗，提高程序响应速度。下面我们深入的分析一下 Java 线程池的实现。

## 基本使用
我们首先看下线程池的基本使用。在下面的代码中我们创建一个固定大小的线程池，该线程池中最多包含 5 个线程，当任务数量超过线程的数量时，就将任务添加到任务队列，等线程空闲之后再从任务队列中获取数据。
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Created by Jikai Zhang on 2017/4/17.
 */
public class ThreadPoolDemo {

    static class WorkThread implements Runnable {
        private String command;

        public WorkThread(String command) {
            this.command = command;
        }

        @Override
        public void run() {
            System.out.println("Thread-" + Thread.currentThread().getId() + " start. Command=" + command);
            processCommand();
            System.out.println("Thread-" + Thread.currentThread().getId() + " end.");
        }

        private void processCommand() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {

            Runnable work = new WorkThread("" + i);
            executor.execute(work);
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
        }
        System.out.println("Finish all threads.");
    }
}
```
## ThreadPoolExecutor


ThreadPoolExecutor 是线程池的具体实现类，我们从源码分析下该类的实现。

### ctl
在 ThreadPoolExecutor 中定义了一个控制变量 ctl，该变量是一个 AtomicInteger 类型的变量，可以原子的进行修改。下面是该变量的定义：
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```
ctl 主要保存两个信息：线程的数量和线程池的状态。ctl 使用低 29 位保存线程的数量，高 3 位保存线程的状态。为了提取出这两个信息，ThreadPoolExecutor 定义了一个低 29 位全为 1 的变量 CAPACITY，通过和 CAPACITY 进行与运算可以获得线程的数量信息，通过和 ~CAPACITY 进行与运算可以获得线程的状态，下面是程序中的实现：

```java
// 存储线程数量的 bit 位数，这里是 29
private static final int COUNT_BITS = Integer.SIZE - 3;

// 用于提取线程的运行状态以及线程数量，低 29 位全为 1，高 3 位为0
private static final int CAPACITY = (1 << COUNT_BITS) - 1;

// 获得线程的运行状态
private static int runStateOf(int c) {
    return c & ~CAPACITY;
}

// 获得线程的数量
private static int workerCountOf(int c) {
    return c & CAPACITY;
}
```
程序定义了下面五种状态：
* RUNNING：接受新的任务，并处理任务队列中的任务
* SHUTDOWN：不接受新的任务，但是处理已经在任务队列中的任务
* STOP: 不接受新的任务，也不处理已经在任务队列中的任务，同时会中断正在执行的任务
* TIDYING: 所有的任务都终止了（terminated），任务量变为 0，该状态的线程会执行 terminated() 方法
* TERMINATED：terminated()方法执行完毕

下面是 JDK 中关于这 5 个变量的定义：
```java
// 11100000000000000000000000000000  -536870912
private static final int RUNNING = -1 << COUNT_BITS;

// 00000000000000000000000000000000  0
private static final int SHUTDOWN = 0 << COUNT_BITS;

// 00100000000000000000000000000000  536870912
private static final int STOP = 1 << COUNT_BITS;

// 01000000000000000000000000000000  1073741824
private static final int TIDYING = 2 << COUNT_BITS;

// 01100000000000000000000000000000  1610612736
private static final int TERMINATED = 3 << COUNT_BITS;
```
下面是各状态之间的转换：

* RUNNING -> SHUTDOWN：调用了 shutdown() 方法，可能在 finailze 中隐式调用了
* (RUNNING or SHUTDOWN) -> STOP：调用了shutdownNow() 方法
* SHUTDOWN -> TIDYING：线程池和任务队列都为空
* STOP -> TIDYING：线程池为空
* TIDYING -> TERMINATED：当执行完 terminated() 方法


### 程序流程
ThreadPoolExecutor 通过 execute 方法添加任务，下面是该方法的实现：
```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */


    int c = ctl.get();
    // 线程数量少于 corePoolSize
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 线程数量大于等于 corePoolSize，首先尝试将任务添加到任务队列
    if (isRunning(c) && workQueue.offer(command)) {
    	// 重新检查状态
        int recheck = ctl.get();
        if (!isRunning(recheck) && remove(command)) {
            reject(command);
        } else if (workerCountOf(recheck) == 0) {
            addWorker(null, false);
        }
    } else if (!addWorker(command, false))
        reject(command);
}
```
在 execute 方法执行时，有三种情况：
* 如果线程池的线程数量少于 corePoolSize，则新建一个线程，变将当前任务作为该线程的第一个任务
* 如果线程池中的线程数量大于等于 corePoolSize，则将任务添加到任务队列
* 如果任务队列已满，则尝试新建一个线程。如果失败，证明当前线程已饱和。

下面我们看下添加任务的逻辑：
```java
private boolean addWorker(Runnable firstTask, boolean core) {
    // retry 类似于 goto，continue retry 跳转到 retry 定义，而 break retry 跳出 retry
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        /**
         * 这条语句等价于：rs >= SHUTDOWN && (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())
         * 首先 rs >= SHUTDOWN 表明程序不再接受新的任务
         * rs != SHUTDOWN: 说明程序的状态为 STOP， TIDYING，TERMINATED，在这三种状态下，程序无需再执行剩余的任务
         * firstTask != null: 说明传入的是一个正常的任务，firstTask == null 说明还有剩余的任务，需要创建线程
         * workQueue.isEmpty()： 说明任务队列中没有剩余的任务了。如果有剩余的任务，还要创建线程继续把任务执行完
         */

        if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            // 线程数量大于阈值 或者 大于 corePoolSize/maximumPoolSize 表明线程池中无法添加新的线程
            if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize)) {
                return false;
            }
            // 使用 CAS 方式将线程数量增加，如果成功就跳出 retry
            if (compareAndIncrementWorkerCount(c)) {
                break retry;
            }

            c = ctl.get(); // Re-read ctl
            // 如果线程池运行状态发生了改变就从retry （外层循环）处重新开始，
            if (runStateOf(c) != rs)
                continue retry;

            // 程序执行到这里说 CAS 没有成功，那么就再次执行 CAS
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建 work
        w = new Worker(firstTask);
        final Thread t = w.thread;
        // t != null 说明线程创建成功了
        if (t != null) {
            // 程序用一个 HashSet 存储线程，而 HashSet 不是线程的安全的，所以将线程加入 HashSet 的过程需要加锁。
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                // rs < SHUTDOWN 说明程序在运行状态
                if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                    // 线程是存活状态说明线程提前开始了。
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```
我们下面看下 Work 类，Work 类继承了AbstractQueuedSynchronizer，实现了Runnable接口。 在 Work 类中使用自定义的不可重入式独占锁，我们看下 Work 构造方法：
```java
Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
}
```
我们看到 Worker 中的 Thread 运行的 Runnable 就是 Worker 自身，下面看下 Worker 的 run 方法：
```java
public void run() {
    runWorker(this);
}
```
我们看到 run 方法最终调用了 runWorker 方法，并且将自身作为参数传进去了，下面是 runWorker 方法的实现：
```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        // 如果任务不为空，说明是刚创建线程，如果任务为空，则从队列中取任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x;
                    throw x;
                } catch (Error x) {
                    thrown = x;
                    throw x;
                } catch (Throwable x) {
                    thrown = x;
                    throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```
在程序最后会执行 processWorkerExit 方法来进行收尾

## 参考文章
* [Java线程池架构(一)原理和源码解析](http://ifeve.com/java-threadpoolexecutor/)
* [Java线程池--原理及源码分析](http://www.jianshu.com/p/117571856b28)
* [http://blog.csdn.net/qq_35101189/article/details/55804778](http://blog.csdn.net/qq_35101189/article/details/55804778)
* [http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor](http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor)
