# 线程池
<!-- toc -->

## 前言
线程池是并发中一项常用的优化方法，通过将线程保存起来，减少线程的创建，降低资源消耗，提高程序响应速度。下面我们深入的分析一下 Java 线程池的实现。

## 基本使用
我们首先看下线程池的基本使用。在下面的代码中我们创建一个固定大小的线程池，该线程池中最多包含 5 个线程，当任务数量超过线程的数量时，就将任务添加到任务队列，等线程空闲之后再从任务队列中获取数据。
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Created by Jikai Zhang on 2017/4/17.
 */
public class ThreadPoolDemo {

    static class WorkThread implements Runnable {
        private String command;

        public WorkThread(String command) {
            this.command = command;
        }

        @Override
        public void run() {
            System.out.println("Thread-" + Thread.currentThread().getId() + " start. Command=" + command);
            processCommand();
            System.out.println("Thread-" + Thread.currentThread().getId() + " end.");
        }

        private void processCommand() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {

            Runnable work = new WorkThread("" + i);
            executor.execute(work);
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
        }
        System.out.println("Finish all threads.");
    }
}
```

## 概述
线程池是通过 ThreadPoolExecutor 来实现的，在分析该类的实现之前，我们首先看下包含的基本内容。
* 任务的添加
* 线程池状态
* 线程池的关闭

### 线程池概述

线程池一般都会关联一个任务队列，用来缓存任务。JDK 中使用阻塞队列作为任务队列，当任务队列为空时，线程就会处于阻塞状态。

ThreadPoolExecutor 实际上是由两个部分组成：线程池和任务队列。当线程池的线程数量到达一定的阈值之后，会首先将任务放到任务队列中，然后线程池中的线程执行完之后，再去任务队列中取任务。任务队列使用阻塞队列来实现，所以当任务队列为空时，线程会进入阻塞状态。线程池通过两个变量来控制线程数量：corePoolSize 和 maximumPoolSize，当线程池线程数量少于 corePoolSize 时，对于每个任务，都会创建一个新的线程来处理（即便线程池中有空闲的线程），然后将新建的线程加入到线程池中，此时该线程被记为 core 线程，默认情况下 core 线程会一直存活在线程池中（也可以设为超时销毁）。当线程池的线程数量大于等于 corePoolSize 时，如果再添加任务，会将任务缓存到任务队列中。线程池中的工作线程执行完当前任务之后会从任务队列中取下一任务进行执行。如果将任务添加到任务队列时，发现任务队列（对于有边界的任务队列）也已经饱和了，此时会再创建新的线程来处理当前任务，新建的线程也会被加入到线程池中，此时该线程被标记为非 core 线程，默认情况下，非 core 在线程池中空闲一段时间后，就会被销毁。非 core 线程主要用来处理某段时间并发任务特别多的情况，即之前的线程配置无法及时处理那么多的任务量，需要额外的线程来帮助。而当这批任务处理完成之后，额外的线程就有些多余了，因此需要及时销毁。

线程池的最大线程数量是有上限的，JDK 中定义线程数量上限是： 536870911，用户可以自定义最大数量数量，在处理时会选两者之间的较小值。当线程池的线程数量等于 maximumPoolSize 时，说明线程池也已经饱和了，此时对于新来的任务就要执行 reject 策略，JDK 中定义了四种拒绝策略：
* AbortPolicy：直接抛出异常，默认策略
* CallerRunsPolicy：使用调用者所在的线程执行任务
* DiscardOldestPolicy：丢弃当前任务队列中最前面的任务，并执行 execute 方法添加任务
* DiscardPolicy：直接丢弃任务

下面再看一下线程池的关闭，线程池的关闭分为两种：平缓关闭（shutdown）和立即关闭（shutdownNow）。这两者的不同就在于如何对待等待队列中的任务，平缓关闭会等待所有任务完成之后再将线程回收，而立即关闭会将立刻回收线程，并且将未完成的任务返回。在平缓关闭过程中，会首先检查线程是否处于空闲状态（通过一个互斥锁实现，如果发现可以获取锁，说明线程处于空闲状态），如果发现线程处于空闲状态，说明当前线程正在被任务队列阻塞，那么对该该线程进行中断，使其退出阻塞状态。

## ThreadPoolExecutor
ThreadPoolExecutor 是线程池的具体实现类，我们从源码分析下该类的实现。

### Worker
ThreadPoolExecutor 中使用 Worker 类对线程进行包装。 Worker 通过继承 AbstractQueuedSynchronizer，使自身成为一个不可重入的互斥锁（注意这里是不可重入的，也就是说该锁只能被一个线程获取一次），该 Worker 对象关联的线程要执行任务时，需要首先获得该 Worker 锁。该锁的主要作用就是为了在关闭线程池时，判断线程是否在执行任务（根据能否获得线程对应的 worker 锁）。同时 Worker 还实现了 Runnable 接口。下面是 Worker 的实现，我们只保留了一些必要的内容：
```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {

    // 当前 Worker 对象关联的线程
    final Thread thread;
    // 线程创建后的初始任务
    Runnable firstTask;
    // 线程完成的任务数量
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        // 只有 state 为 0，线程才能获取 worker 锁，这里将 state 设为 -1，
        // 表明其他线程无法获取锁，也就无法对该 Worker 对象关联的线程进行中断操作
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }
}
```
我们看到在 Worker 的构造函数中将 state 设为了 -1，注释里给出的解释是：禁止中断直到执行了 runWorker 方法。在前面我们提到，如果想要对当前线程执行中断，需要首先获得该线程所关联的 Worker 互斥锁，当获取 Worker 互斥锁的前提是 Worker 对象中的 state 状态为 0，当设为了 -1 之后，任何线程都无法获得该锁，那么也就无法对线程执行中断操作。当执行 runWorker 方法时，会为传入 Worker 对象执行 unlock 操作（也就是将 state 加 1），使 Worker 对象的 state 变为 0，也就是使该锁处于可获取的状态。在下面的过程中，我们会具体分析。

### 控制变量
在 ThreadPoolExecutor 中定义了一个控制变量 ctl，该变量是一个 AtomicInteger 类型的变量，可以原子的进行修改。下面是该变量的定义：
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```
ctl 主要保存两个信息：线程的数量和线程池的状态。ctl 使用低 29 位保存线程的数量，高 3 位保存线程的状态。为了提取出这两个信息，ThreadPoolExecutor 定义了一个低 29 位全为 1 的变量 CAPACITY，通过和 CAPACITY 进行与运算可以获得线程的数量信息，通过和 ~CAPACITY 进行与运算可以获得线程的状态，下面是程序中的实现：

```java
// 存储线程数量的 bit 位数，这里是 29
private static final int COUNT_BITS = Integer.SIZE - 3;

// 用于提取线程的运行状态以及线程数量，低 29 位全为 1，高 3 位为0
private static final int CAPACITY = (1 << COUNT_BITS) - 1;

// 获得线程的运行状态
private static int runStateOf(int c) {
    return c & ~CAPACITY;
}

// 获得线程的数量
private static int workerCountOf(int c) {
    return c & CAPACITY;
}
```
程序定义了下面五种状态：
* RUNNING：接受新的任务，并处理任务队列中的任务
* SHUTDOWN：不接受新的任务，但是处理已经在任务队列中的任务
* STOP: 不接受新的任务，也不处理已经在任务队列中的任务，同时会中断正在执行的任务
* TIDYING: 所有的任务都终止了（terminated），任务量变为 0，该状态的线程会执行 terminated() 方法
* TERMINATED：terminated()方法执行完毕

下面是 JDK 中关于这 5 个变量的定义：
```java
// 11100000000000000000000000000000  -536870912
private static final int RUNNING = -1 << COUNT_BITS;

// 00000000000000000000000000000000  0
private static final int SHUTDOWN = 0 << COUNT_BITS;

// 00100000000000000000000000000000  536870912
private static final int STOP = 1 << COUNT_BITS;

// 01000000000000000000000000000000  1073741824
private static final int TIDYING = 2 << COUNT_BITS;

// 01100000000000000000000000000000  1610612736
private static final int TERMINATED = 3 << COUNT_BITS;
```
下面是各状态之间的转换：

* RUNNING -> SHUTDOWN：调用了 shutdown() 方法，可能在 finailze 中隐式调用了
* (RUNNING or SHUTDOWN) -> STOP：调用了shutdownNow() 方法
* SHUTDOWN -> TIDYING：线程池和任务队列都为空
* STOP -> TIDYING：线程池为空
* TIDYING -> TERMINATED：当执行完 terminated() 方法


### 添加任务
我们首次来看往线程池中添加任务的逻辑。通过 execute 方法会向线程池中添加一个任务，下面是该方法的实现：
```java
public void execute(Runnable command) {
    // command 不能为 null
    if (command == null)
        throw new NullPointerException();

    int c = ctl.get();
    // 线程数量少于 corePoolSize，会创建一个新的线程执行该任务
    if (workerCountOf(c) < corePoolSize) {
        // true 表示当前添加的线程为核心线程
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }

    // 线程数量大于等于 corePoolSize，首先尝试将任务添加到任务队列
    // workQueue.offer 会将任务添加到队列尾部
    if (isRunning(c) && workQueue.offer(command)) {

        // 重新检查状态
        int recheck = ctl.get();

        // 如果发现当前线程池不是出于 Running 状态，就移除之前的任务
        // 移除任务过程有锁保护
        if (!isRunning(recheck) && remove(command)) {
            reject(command);
        } else if (workerCountOf(recheck) == 0) {

            // 程序执行到这里，说明一下几点
            //  1. 当前线程池不在处于 Running 状态，也就是不在接受新的任务
            //  2. workerCountOf 用来当前的工作线程数量，为 0 表明当前
            //      没有工作线程，但是还有其他的任务没有完成
            //  3. 为了完成剩余的任务，需要创建新的线程，这里向 addWorker
            //      里传入 null，为了表明当前创建的线程是为了执行任务队列
            //      中剩余的任务，在 addWorker 里对 null 有专门的处理逻辑
            addWorker(null, false);
        }

    } else if (!addWorker(command, false)) { // 这里说明任务队列满了
        reject(command);
    }
}
```
在前面我们提到了线程池添加任务的工作，这里再重述一下
* 如果线程池的线程数量少于 corePoolSize，则新建一个线程，执行当前任务，并将该任务加入到线程池
* 如果线程池中的线程数量大于等于 corePoolSize，则首先将任务添加到任务队列
* 如果任务队列已满，则继续创建线程，如果线程池达到了饱和值 maximumPoolSize，则调用 reject 策略处理该任务。

addWorker 方法执行创建线程的工作，下面是它的实现
```java
private boolean addWorker(Runnable firstTask, boolean core) {
    // retry 类似于 goto，continue retry 跳转到 retry 定义，
    // 而 break retry 跳出 retry
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        /**
         * 这条语句等价于：rs >= SHUTDOWN && (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())
         * 首先 rs >= SHUTDOWN 表明程序不再接受新的任务
         * rs != SHUTDOWN: 说明程序的状态为 STOP， TIDYING，TERMINATED，在这三种状态下，程序无需再执行剩余的任务
         * firstTask != null: 说明传入的是一个正常的任务，firstTask == null 说明还有剩余的任务，需要创建线程
         * workQueue.isEmpty()： 说明任务队列中没有剩余的任务了。如果有剩余的任务，还要创建线程继续把任务执行完
         */
        // 我们在下面详细讲解该条件
        if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            // 线程数量大于系统规定的最大线程数
            // 或者 大于 corePoolSize/maximumPoolSize 表明线程池中无法添加新的线程
            // 这里 wc >= CAPACITY 为了防止 corePoolSize或者 maximumPoolSize大于CAPACITY
            if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize)) {
                return false;
            }
            // 使用 CAS 方式将线程数量增加，如果成功就跳出 retry
            if (compareAndIncrementWorkerCount(c)) {
                break retry;
            }

            c = ctl.get(); // Re-read ctl
            // 如果线程池运行状态发生了改变就从retry （外层循环）处重新开始，
            if (runStateOf(c) != rs)
                continue retry;

            // 程序执行到这里说 CAS 没有成功，那么就再次执行 CAS
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建 work
        w = new Worker(firstTask);
        final Thread t = w.thread;
        // t != null 说明线程创建成功了
        if (t != null) {
            // 程序用一个 HashSet 存储线程，而 HashSet 不是线程的安全的，
            // 所以将线程加入 HashSet 的过程需要加锁。
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                // 1. rs < SHUTDOWN 说明程序在运行状态
                // 2. rs == SHUTDOWN  说明当前线程处于平缓关闭状态，而 firstTask == null
                //    说明当前创建的线程是为了处理任务队列中剩余的任务，所以故意传入 null
                if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                    // 线程是存活状态说明线程提前开始了。
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```
这里我们着重看下返回 false 的条件：
```java
if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
// 等价于
if(rs >= SHUTDOWN &&(rs != SHUTDOWN || firstTask != null || workQueue.isEmpty()))
```
我们依次看下上面的条件：
* rs >= SHUTDOWN && rs != SHUTDOWN：说明线程池处于 STOP，TIDYING 或者 TERMINATED 状态下，处于这三种状态说明线程池处理完了所有任务或者不再执行剩余的任务，可以直接返回
* rs == SHUTDOWN && firstTask != null：如果上面的条件不成立，说明当前线程池的状态一定是处于 SHUTDOWN，在 execute 方法中，我们提到了如果传入 null，说明创建线程是为了执行队列中剩余的任务（此时没有工作线程），这时就不应该返回。而如果 firstTask != null，说明不是为了处理队列中剩余的任务，可以返回。
* rs == SHUTDOWN && workQueue.isEmpty()：说经任务队列中的任务已经全部执行完了，无需创建新的线程，可以返回。

当创建了线程并成功启动之后，会执行 Worker 的 run 方法，而该方法最终调用了 runWorker 方法，并且将自身作为参数传进去了，下面是 runWorker 方法的实现：
```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 这里将 Worker 中的 state 设为 0，以便其他线程可以获得锁
    // 从而可以中观当前线程
    w.unlock(); // allow interrupts
    // 用来标记任务是否成功完成
    boolean completedAbruptly = true;
    try {
        // 如果任务不为空，说明是刚创建线程，如果任务为空，则从队列中取任务
        // 如果队列没有任务，线程就会阻塞在这里
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted())
                wt.interrupt();
            try {
                // 任务执行之前做一些处理，空函数，需要用户定义处理逻辑
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x;
                    throw x;
                } catch (Error x) {
                    thrown = x;
                    throw x;
                } catch (Throwable x) {
                    thrown = x;
                    // 因为 runnable 方法不能抛出 checkedException ，所以这里
                    // 将异常包装成 Error 抛出
                    throw new Error(x);
                } finally {
                    // 任务执行完之后做一些处理，默认空函数
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```
在上面的代码中，第一个 if 判断的逻辑有点难理解，我们将它拿出分析一下。
```java
private static boolean runStateAtLeast(int c, int s) {
    return c >= s;
}

if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)))
    && !wt.isInterrupted())
    wt.interrupt();
```
这段 if 代码块的功能有两个：
* 如果当前线程池的状态小于 STOP，也就是处于 RUNNING 或者 SHUTDOWN 状态，要保证线程池中的线程处于非中断状态
* 如果当前线程池的状态大于等于 STOP，也就是处于 STOP，TIDYING 或者 TERMINATED 状态，要保证线程池中的线程处于中断状态

上面的 if 代码中括号比较多，我们先将其分为两个大条件：
* runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)) &&
* !wt.isInterrupted()

我们先看第二个条件：!wt.isInterrupted()，该条件说明当前线程没有被中断，只有在线程没有被中断的前提下，才有可能对线程执行中断操作。然后我们将第一个大条件再进行拆分，可以分为下面两个条件：
* runStateAtLeast(ctl.get(), STOP) ||
* Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)

我们先看第一个条件，该条件说明线程处于 STOP 以及之后的状态，线程应该被中断。如果该条件不成立，说明当前线程不应该被中断，那么会调用 Thread.interrupted() 方法，该方法会首返回线程的中断状态，然后重置线程中断状态（设为 false），如果中断状态本来就为 false，那么就可以就可以跳出 if 代码块了，但是如果中断状态是 true，说明线程被中断过了，此时我们就要判断线程的中断是不是由 shutdownNow 方法（并发调用，该方法会中断线程池的线程，并修改线程池状态为 STOP，后面会讲到）造成的，所以我们需要再检查一下线程的状态，如果发现当前线程池已经变为 STOP 或者之后的状态，说明确实是由 shutdownNow 方法造成的，需要重新对线程进行中断，如果不是那就不需要再中断线程了。

下面我们再看下 getTask 的逻辑：
```java
/**
 * getTask 返回 null，说明当前线程需要被回收了
 */
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // rs >= SHUTDOWN 说明当前线程池至少处于待关闭状态，不再接受新的任务
        //  1. rs >= STOP： 说明不需要在再处理任务了（即便有任务）
        //  2. workQueue.isEmpty(): 说明任务队列中剩余的任务已经处理完了
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        // timed 用于判断是否需要对线程进行超时控制
        //  1. allowCoreThreadTimeOut: 为 true 说明可以对 core 线程进行超时控制
        //  2. wc > corePoolSize: 说明线程池中有非 core 线程
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        // 1. wc > maximumPoolSize || (timed && timedOut)
        //     线程数量大于 maximumPoolSize 值了 或者 允许超时控制并且超时了
        // 2. wc > 1 || workQueue.isEmpty()
        //     线程中活动线程的数量大于 1 或者 任务队列为空（不需要在留线程执行剩余的任务了）
        // 如果上面 1 和 2 都成立，就使用 CAS 将线程数量减 1 并返回 null 回收当前线程
        // 如果 CAS 失败了就重试
        if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 如果允许超时控制，则执行 poll 方法，该方法响应超时，当 keepAliveTime 时间内
            // 仍然没有获取到任务，就返回 null。take 方法不响应超时操作，当获取不到任务时会一直等待。
            // 另外不管 poll 还是 take 方法都会响应中断，如果没有新的任务添加到队列中
            // 会直接抛出 InterruptedException
            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();
            if (r != null)
                return r;

            // 执行到这里说明超时了
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```
当 getTask 返回 null 的时候说明线程需要被回收了，我们总结一下在 getTask 中返回 null 的情况：
* 线程池总工作线程数量大于 maximumPoolSize（一般是由于我们调用 setMaximumPoolSize 重新设置了 maximumPoolSize）
* 线程池已经被停止 （状态 >= STOP）
* 线程池处于 SHUTDOWN 状态，并且任务队列为空
* 线程在等待任务时超时

我们将 runWorker 和 getTask 结合起来看，整个流程就比较明朗了：
1. 通过 while 循环不断的从任务队列中获取任务，如果当前任务队列中没有任务，就阻塞线程。如果返回 null，表明当前线程应该被回收，执行回收线程的逻辑。
2. 如果成功获取任务，首先判断线程池的状态，根据线程池状态设置当前线程的中断状态
3. 在执行任务之前做一些预处理（用户实现）
4. 执行任务
5. 在执行任务之后做一些后处理（用户实现）

上面两个方法是整个线程池中比较核心的部分，在这个两个方法中，完成了任务获取与阻塞线程的工作。下面我们再看下 processWorkerExit 方法，该方法主要用来完成线程的回收工作：
```java
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    // 如果 completedAbruptly 为 true，说明线程是由于抛出异常而跳出循环的，
    // 没有正确执行 getTask 中减少线程数量的逻辑，所以这里要将线程数量减一
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 更新已完成的任务数量，并移除工作线程
        completedTaskCount += w.completedTasks;
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    // 根据线程池状态判断是否结束线程
    tryTerminate();

    int c = ctl.get();

    // 如果线程状态是 SHUTDOWN 或者 RUNNING，需要保证线程中的最少线程数量
    // 1. 如果线程是由于抛出异常而结束的，直接添加一个线程
    // 2. 如果线程是正常结束的
    //    * 如果允许对 core 线程进行超时控制，并且任务队列中有任务
    //      则保证线程数量大于等于 1
    //    * 如果不允许对 core 进行超时控制，则保证线程数量大于等于 corePoolSize
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && !workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
```
processWorkerExit 中调用了 tryTerminate 来尝试关闭线程，我们来看下具体的实现逻辑：
```java
/**
 *
 */
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        // 如果出现下面三种情况，就不执行停止线程的逻辑，直接返回
        //  1. 当前线程池处于 RUNNING 状态，不能停止
        //  2. 当前线程池状态为 TIDYING 或者 TERMINATED，不需要停止
        //  3. 当前线程池状态为 SHUTDOWN 并且任务队列不为空
        if (isRunning(c) || runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && !workQueue.isEmpty()))
            return;
        // 判断工作线程的数量是否为 0
        if (workerCountOf(c) != 0) { // Eligible to terminate
            // 如果工作线程数量不能 0，就尝试中断正在线程池中的空闲线程
            // ONLY_ONE 说明只尝试中断线程池中第一个线程（不管线程空不空闲）
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 将线程状态设为 TIDYING，如果设置不成功说明线程池的状态发生了变化，需要重试
            // 这里线程池状态从 TIDYING 到 TERMINATED 状态转换是原子的
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // 执行 terminated 方法（默认空方法）
                    terminated();
                } finally {
                    // 将线程状态设为 TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
```
在 tryTerminate 方法中， 如果满足下面两个条件，就将线程池状态设为 TERMINATED
1. 线程池状态为 SHUTDOWN 并且线程池和任务队列均为空
2. 线程池状态为 STOP 并且线程池为空

如果线程池处于 SHUTDOWN 或者 STOP 状态，但是工作线程不为空，就尝试去中断线程中的一个线程，为什么这样做我们后面再说。我们首次看下 interruptIdleWorkers 方法
```java
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w: workers) {
            Thread t = w.thread;
            // 首先看当前线程是否已经中断，如果没有中断，就看线程是否处于空闲状态
            // 如果能获得线程关联的 Worker 锁，说明线程可以中断
            // 否则说明线程不能中断
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {} finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```



## 参考文章
* [Java线程池架构(一)原理和源码解析](http://ifeve.com/java-threadpoolexecutor/)
* [Java线程池--原理及源码分析](http://www.jianshu.com/p/117571856b28)
* [http://blog.csdn.net/qq_35101189/article/details/55804778](http://blog.csdn.net/qq_35101189/article/details/55804778)
* [http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor](http://zhanjindong.com/2015/03/30/java-concurrent-package-ThreadPoolExecutor)
* [深入理解Java线程池：ThreadPoolExecutor](http://ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/)
